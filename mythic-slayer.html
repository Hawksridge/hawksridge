<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mythic Slayer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Georgia', serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
        }
        #gameCanvas {
            border: 4px solid #c9a227;
            border-radius: 8px;
            cursor: crosshair;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #f0e68c;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        #upgradeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.95);
            border: 3px solid #c9a227;
            border-radius: 15px;
            padding: 30px;
            display: none;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #upgradeMenu h2 {
            color: #c9a227;
            text-align: center;
            margin-bottom: 20px;
            font-size: 28px;
        }
        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .upgrade-btn {
            background: linear-gradient(145deg, #2a2a4e, #1a1a2e);
            border: 2px solid #c9a227;
            color: #f0e68c;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Georgia', serif;
        }
        .upgrade-btn:hover {
            background: linear-gradient(145deg, #3a3a6e, #2a2a4e);
            transform: scale(1.05);
        }
        .upgrade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .upgrade-btn .name { font-weight: bold; font-size: 16px; }
        .upgrade-btn .desc { font-size: 12px; color: #aaa; margin: 5px 0; }
        .upgrade-btn .cost { color: #ffd700; font-size: 14px; }
        .upgrade-btn .level { color: #88ff88; font-size: 12px; }
        #startWaveBtn {
            display: block;
            margin: 0 auto;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(145deg, #4a7c3f, #2e5a24);
            border: 2px solid #7cb342;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Georgia', serif;
        }
        #startWaveBtn:hover {
            background: linear-gradient(145deg, #5a9c4f, #3e7a34);
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f0e68c;
        }
        #startScreen h1 {
            font-size: 48px;
            color: #c9a227;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            margin-bottom: 10px;
        }
        #startScreen .subtitle {
            font-size: 18px;
            margin-bottom: 30px;
            color: #aaa;
        }
        .class-select {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        .class-btn {
            padding: 20px;
            font-size: 18px;
            background: linear-gradient(145deg, #2a2a4e, #1a1a2e);
            border: 3px solid #555;
            color: #f0e68c;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            transition: all 0.3s;
        }
        .class-btn:hover {
            transform: scale(1.05);
        }
        .class-btn.selected {
            border-color: #c9a227;
            box-shadow: 0 0 20px rgba(201, 162, 39, 0.5);
        }
        .class-btn .class-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .class-btn .class-desc {
            font-size: 12px;
            color: #aaa;
        }
        .class-btn.mage { border-color: #6a5acd; }
        .class-btn.mage.selected { border-color: #9370db; box-shadow: 0 0 20px rgba(147, 112, 219, 0.5); }
        .class-btn.barbarian { border-color: #8b0000; }
        .class-btn.barbarian.selected { border-color: #dc143c; box-shadow: 0 0 20px rgba(220, 20, 60, 0.5); }
        .class-btn.ninja { border-color: #2f4f4f; }
        .class-btn.ninja.selected { border-color: #5f9f9f; box-shadow: 0 0 20px rgba(95, 159, 159, 0.5); }
        .class-btn.knight { border-color: #b8860b; }
        .class-btn.knight.selected { border-color: #ffd700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
        #startBtn {
            padding: 20px 50px;
            font-size: 24px;
            background: linear-gradient(145deg, #8b0000, #5a0000);
            border: 3px solid #c9a227;
            color: #f0e68c;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            opacity: 0.5;
            pointer-events: none;
        }
        #startBtn.enabled {
            opacity: 1;
            pointer-events: auto;
        }
        #startBtn.enabled:hover {
            background: linear-gradient(145deg, #ab2020, #7a1010);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f0e68c;
            display: none;
        }
        #gameOver h1 { font-size: 48px; color: #8b0000; margin-bottom: 20px; }
        .controls {
            font-size: 14px;
            color: #888;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        <div id="ui">
            <div id="health">Health: 100</div>
            <div id="score">Score: 0</div>
            <div id="souls">Souls: 0</div>
            <div id="wave">Wave: 1</div>
            <div id="enemies">Enemies: 0</div>
            <div id="classDisplay">Class: -</div>
        </div>
        <div id="startScreen">
            <h1>MYTHIC SLAYER</h1>
            <p class="subtitle">Slay legendary creatures from myth and legend</p>
            <p style="color:#c9a227;margin-bottom:15px;">Choose Your Class:</p>
            <div class="class-select">
                <button class="class-btn mage" data-class="mage">
                    <div class="class-name">MAGE</div>
                    <div class="class-desc">Arcane projectiles, high damage, fragile<br>Special: Piercing magic bolts</div>
                </button>
                <button class="class-btn barbarian" data-class="barbarian">
                    <div class="class-name">BARBARIAN</div>
                    <div class="class-desc">Throwing axes, tanky, rage mode<br>Special: Attacks grow stronger when hurt</div>
                </button>
                <button class="class-btn ninja" data-class="ninja">
                    <div class="class-name">NINJA</div>
                    <div class="class-desc">Shurikens, fast, critical hits<br>Special: High speed & crit chance</div>
                </button>
                <button class="class-btn knight" data-class="knight">
                    <div class="class-name">KNIGHT</div>
                    <div class="class-desc">Balanced, durable, steady damage<br>Special: Damage reduction & life regen</div>
                </button>
            </div>
            <button id="startBtn">BEGIN THE HUNT</button>
            <div class="controls">
                <p>WASD or Arrow Keys to move | Mouse to aim | Hold Left Click to fire</p>
            </div>
        </div>
        <div id="upgradeMenu">
            <h2>UPGRADE YOUR ARSENAL</h2>
            <div id="soulsDisplay" style="text-align:center;color:#ffd700;font-size:20px;margin-bottom:20px;">Souls: 0</div>
            <div class="upgrade-grid" id="upgradeGrid"></div>
            <button id="startWaveBtn">START NEXT WAVE</button>
        </div>
        <div id="gameOver">
            <h1>FALLEN IN BATTLE</h1>
            <p id="finalScore">Final Score: 0</p>
            <p id="finalWave">Reached Wave: 1</p>
            <button id="restartBtn" style="margin-top:20px;padding:15px 30px;font-size:18px;background:#8b0000;border:2px solid #c9a227;color:#f0e68c;border-radius:8px;cursor:pointer;">TRY AGAIN</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        const SPAWN_PROTECTION_RADIUS = 200;

        // ===== ENHANCED SOUND SYSTEM =====
        let audioCtx = null;
        let soundEnabled = true;
        let masterGain = null;
        let reverbNode = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.7;
                masterGain.connect(audioCtx.destination);

                // Create simple reverb
                const reverbTime = 0.3;
                const sampleRate = audioCtx.sampleRate;
                const length = sampleRate * reverbTime;
                const impulse = audioCtx.createBuffer(2, length, sampleRate);
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                reverbNode = audioCtx.createConvolver();
                reverbNode.buffer = impulse;
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function createNoise(duration) {
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            return noise;
        }

        function playSound(type, volume = 0.3) {
            if (!soundEnabled || !audioCtx) return;
            const now = audioCtx.currentTime;

            switch(type) {
                case 'shoot': {
                    // Layered laser with harmonics
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const osc3 = audioCtx.createOscillator();
                    const filter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(3000, now);
                    filter.frequency.exponentialRampToValueAtTime(500, now + 0.08);
                    filter.Q.value = 2;

                    osc1.type = 'sawtooth';
                    osc2.type = 'square';
                    osc3.type = 'sine';

                    osc1.frequency.setValueAtTime(880, now);
                    osc1.frequency.exponentialRampToValueAtTime(220, now + 0.08);
                    osc2.frequency.setValueAtTime(440, now);
                    osc2.frequency.exponentialRampToValueAtTime(110, now + 0.08);
                    osc3.frequency.setValueAtTime(1760, now);
                    osc3.frequency.exponentialRampToValueAtTime(440, now + 0.06);

                    const mix = audioCtx.createGain();
                    mix.gain.value = 0.33;

                    osc1.connect(mix);
                    osc2.connect(mix);
                    osc3.connect(mix);
                    mix.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(volume * 0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

                    osc1.start(now);
                    osc2.start(now);
                    osc3.start(now);
                    osc1.stop(now + 0.1);
                    osc2.stop(now + 0.1);
                    osc3.stop(now + 0.1);
                    break;
                }
                case 'hit': {
                    // Punchy impact with sub bass
                    const osc = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const noise = createNoise(0.1);
                    const filter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();
                    const noiseGain = audioCtx.createGain();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(800, now);
                    filter.frequency.exponentialRampToValueAtTime(100, now + 0.08);

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);

                    osc2.type = 'triangle';
                    osc2.frequency.setValueAtTime(400, now);
                    osc2.frequency.exponentialRampToValueAtTime(80, now + 0.08);

                    osc.connect(gain);
                    osc2.connect(gain);
                    noise.connect(filter);
                    filter.connect(noiseGain);
                    noiseGain.connect(gain);
                    gain.connect(masterGain);

                    noiseGain.gain.setValueAtTime(volume * 0.15, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                    gain.gain.setValueAtTime(volume * 0.35, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

                    osc.start(now);
                    osc2.start(now);
                    noise.start(now);
                    osc.stop(now + 0.12);
                    osc2.stop(now + 0.1);
                    noise.stop(now + 0.1);
                    break;
                }
                case 'kill': {
                    // Satisfying splat with body
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const osc3 = audioCtx.createOscillator();
                    const noise = createNoise(0.2);
                    const filter = audioCtx.createBiquadFilter();
                    const noiseFilter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1200, now);
                    filter.frequency.exponentialRampToValueAtTime(80, now + 0.2);
                    filter.Q.value = 3;

                    noiseFilter.type = 'bandpass';
                    noiseFilter.frequency.setValueAtTime(2000, now);
                    noiseFilter.frequency.exponentialRampToValueAtTime(400, now + 0.15);

                    osc1.type = 'sine';
                    osc1.frequency.setValueAtTime(500, now);
                    osc1.frequency.exponentialRampToValueAtTime(60, now + 0.2);

                    osc2.type = 'triangle';
                    osc2.frequency.setValueAtTime(300, now);
                    osc2.frequency.exponentialRampToValueAtTime(40, now + 0.18);

                    osc3.type = 'sawtooth';
                    osc3.frequency.setValueAtTime(150, now);
                    osc3.frequency.exponentialRampToValueAtTime(30, now + 0.15);

                    const oscGain = audioCtx.createGain();
                    oscGain.gain.value = 0.4;

                    osc1.connect(filter);
                    osc2.connect(filter);
                    osc3.connect(oscGain);
                    oscGain.connect(filter);
                    filter.connect(gain);
                    noise.connect(noiseFilter);
                    noiseFilter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(volume * 0.4, now);
                    gain.gain.setValueAtTime(volume * 0.4, now + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

                    osc1.start(now);
                    osc2.start(now);
                    osc3.start(now);
                    noise.start(now);
                    osc1.stop(now + 0.25);
                    osc2.stop(now + 0.2);
                    osc3.stop(now + 0.18);
                    noise.stop(now + 0.2);
                    break;
                }
                case 'playerHit': {
                    // Heavy impact with crunch
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const noise = createNoise(0.25);
                    const distortion = audioCtx.createWaveShaper();
                    const filter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    // Create distortion curve
                    const curve = new Float32Array(256);
                    for (let i = 0; i < 256; i++) {
                        const x = (i - 128) / 128;
                        curve[i] = Math.tanh(x * 3);
                    }
                    distortion.curve = curve;

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(2000, now);
                    filter.frequency.exponentialRampToValueAtTime(150, now + 0.25);

                    osc1.type = 'sawtooth';
                    osc1.frequency.setValueAtTime(150, now);
                    osc1.frequency.exponentialRampToValueAtTime(35, now + 0.25);

                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(75, now);
                    osc2.frequency.exponentialRampToValueAtTime(20, now + 0.2);

                    osc1.connect(distortion);
                    osc2.connect(distortion);
                    noise.connect(filter);
                    distortion.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(volume * 0.5, now);
                    gain.gain.setValueAtTime(volume * 0.45, now + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

                    osc1.start(now);
                    osc2.start(now);
                    noise.start(now);
                    osc1.stop(now + 0.3);
                    osc2.stop(now + 0.25);
                    noise.stop(now + 0.25);
                    break;
                }
                case 'explosion': {
                    // Massive layered explosion
                    const noise1 = createNoise(0.5);
                    const noise2 = createNoise(0.4);
                    const osc = audioCtx.createOscillator();
                    const lowFilter = audioCtx.createBiquadFilter();
                    const midFilter = audioCtx.createBiquadFilter();
                    const highFilter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    lowFilter.type = 'lowpass';
                    lowFilter.frequency.setValueAtTime(300, now);
                    lowFilter.frequency.exponentialRampToValueAtTime(40, now + 0.5);
                    lowFilter.Q.value = 1;

                    midFilter.type = 'bandpass';
                    midFilter.frequency.setValueAtTime(1500, now);
                    midFilter.frequency.exponentialRampToValueAtTime(200, now + 0.3);
                    midFilter.Q.value = 0.5;

                    highFilter.type = 'highpass';
                    highFilter.frequency.setValueAtTime(3000, now);
                    highFilter.frequency.exponentialRampToValueAtTime(800, now + 0.15);

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.exponentialRampToValueAtTime(20, now + 0.4);

                    const lowGain = audioCtx.createGain();
                    const midGain = audioCtx.createGain();
                    const highGain = audioCtx.createGain();

                    lowGain.gain.setValueAtTime(0.6, now);
                    lowGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    midGain.gain.setValueAtTime(0.4, now);
                    midGain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                    highGain.gain.setValueAtTime(0.3, now);
                    highGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

                    noise1.connect(lowFilter);
                    lowFilter.connect(lowGain);
                    osc.connect(lowGain);
                    noise1.connect(midFilter);
                    midFilter.connect(midGain);
                    noise2.connect(highFilter);
                    highFilter.connect(highGain);

                    lowGain.connect(gain);
                    midGain.connect(gain);
                    highGain.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(volume * 0.7, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

                    noise1.start(now);
                    noise2.start(now);
                    osc.start(now);
                    noise1.stop(now + 0.5);
                    noise2.stop(now + 0.4);
                    osc.stop(now + 0.45);
                    break;
                }
                case 'upgrade': {
                    // Magical chime with shimmer
                    const notes = [523, 659, 784, 1047, 1319];
                    notes.forEach((freq, i) => {
                        const osc = audioCtx.createOscillator();
                        const osc2 = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        const filter = audioCtx.createBiquadFilter();

                        filter.type = 'highpass';
                        filter.frequency.value = 400;

                        osc.type = 'sine';
                        osc2.type = 'triangle';
                        osc.frequency.setValueAtTime(freq, now + i * 0.08);
                        osc2.frequency.setValueAtTime(freq * 2.01, now + i * 0.08);

                        const mix = audioCtx.createGain();
                        mix.gain.value = 0.7;

                        osc.connect(gain);
                        osc2.connect(mix);
                        mix.connect(gain);
                        gain.connect(filter);
                        filter.connect(masterGain);

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.setValueAtTime(volume * 0.2, now + i * 0.08);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.5);

                        osc.start(now + i * 0.08);
                        osc2.start(now + i * 0.08);
                        osc.stop(now + i * 0.08 + 0.5);
                        osc2.stop(now + i * 0.08 + 0.5);
                    });
                    break;
                }
                case 'waveStart': {
                    // Epic horn with reverb
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const osc3 = audioCtx.createOscillator();
                    const filter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(800, now);
                    filter.frequency.linearRampToValueAtTime(2000, now + 0.3);
                    filter.frequency.linearRampToValueAtTime(1200, now + 0.8);

                    osc1.type = 'sawtooth';
                    osc2.type = 'sawtooth';
                    osc3.type = 'square';

                    osc1.frequency.setValueAtTime(220, now);
                    osc1.frequency.setValueAtTime(330, now + 0.25);
                    osc1.frequency.setValueAtTime(440, now + 0.5);

                    osc2.frequency.setValueAtTime(221, now);
                    osc2.frequency.setValueAtTime(331, now + 0.25);
                    osc2.frequency.setValueAtTime(441, now + 0.5);

                    osc3.frequency.setValueAtTime(110, now);
                    osc3.frequency.setValueAtTime(165, now + 0.25);
                    osc3.frequency.setValueAtTime(220, now + 0.5);

                    const mix = audioCtx.createGain();
                    mix.gain.value = 0.33;

                    osc1.connect(mix);
                    osc2.connect(mix);
                    osc3.connect(mix);
                    mix.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(0.001, now);
                    gain.gain.exponentialRampToValueAtTime(volume * 0.35, now + 0.1);
                    gain.gain.setValueAtTime(volume * 0.35, now + 0.6);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.9);

                    osc1.start(now);
                    osc2.start(now);
                    osc3.start(now);
                    osc1.stop(now + 0.9);
                    osc2.stop(now + 0.9);
                    osc3.stop(now + 0.9);
                    break;
                }
                case 'waveComplete': {
                    // Triumphant fanfare
                    const chords = [
                        [523, 659, 784],
                        [587, 740, 880],
                        [659, 784, 988],
                        [784, 988, 1175, 1568]
                    ];
                    chords.forEach((chord, i) => {
                        chord.forEach(freq => {
                            const osc = audioCtx.createOscillator();
                            const osc2 = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            const filter = audioCtx.createBiquadFilter();

                            filter.type = 'lowpass';
                            filter.frequency.value = 3000;

                            osc.type = 'triangle';
                            osc2.type = 'sine';
                            osc.frequency.value = freq;
                            osc2.frequency.value = freq * 2;

                            osc.connect(gain);
                            osc2.connect(gain);
                            gain.connect(filter);
                            filter.connect(masterGain);

                            const startTime = now + i * 0.15;
                            gain.gain.setValueAtTime(0, now);
                            gain.gain.linearRampToValueAtTime(volume * 0.15, startTime + 0.02);
                            gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);

                            osc.start(startTime);
                            osc2.start(startTime);
                            osc.stop(startTime + 0.5);
                            osc2.stop(startTime + 0.5);
                        });
                    });
                    break;
                }
                case 'gameOver': {
                    // Dramatic death with dissonance
                    const notes = [392, 370, 349, 311, 294, 262];
                    notes.forEach((freq, i) => {
                        const osc = audioCtx.createOscillator();
                        const osc2 = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        const filter = audioCtx.createBiquadFilter();

                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(2000, now + i * 0.2);
                        filter.frequency.exponentialRampToValueAtTime(400, now + i * 0.2 + 0.5);

                        osc.type = 'sawtooth';
                        osc2.type = 'sine';
                        osc.frequency.value = freq;
                        osc2.frequency.value = freq * 0.5;

                        const mix = audioCtx.createGain();
                        mix.gain.value = 0.5;

                        osc.connect(mix);
                        osc2.connect(gain);
                        mix.connect(filter);
                        filter.connect(gain);
                        gain.connect(masterGain);

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(volume * 0.25, now + i * 0.2 + 0.05);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.2 + 0.6);

                        osc.start(now + i * 0.2);
                        osc2.start(now + i * 0.2);
                        osc.stop(now + i * 0.2 + 0.6);
                        osc2.stop(now + i * 0.2 + 0.6);
                    });
                    break;
                }
                case 'bossSpawn': {
                    // Massive ominous rumble
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const osc3 = audioCtx.createOscillator();
                    const noise = createNoise(1.5);
                    const lfo = audioCtx.createOscillator();
                    const lfoGain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, now);
                    filter.frequency.linearRampToValueAtTime(400, now + 0.5);
                    filter.frequency.linearRampToValueAtTime(100, now + 1.5);

                    lfo.frequency.value = 4;
                    lfoGain.gain.value = 10;
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc1.frequency);

                    osc1.type = 'sawtooth';
                    osc2.type = 'sine';
                    osc3.type = 'triangle';
                    osc1.frequency.setValueAtTime(55, now);
                    osc2.frequency.setValueAtTime(55.5, now);
                    osc3.frequency.setValueAtTime(27.5, now);

                    const noiseFilter = audioCtx.createBiquadFilter();
                    noiseFilter.type = 'lowpass';
                    noiseFilter.frequency.value = 150;

                    osc1.connect(filter);
                    osc2.connect(filter);
                    osc3.connect(filter);
                    noise.connect(noiseFilter);
                    noiseFilter.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(0.001, now);
                    gain.gain.exponentialRampToValueAtTime(volume * 0.5, now + 0.4);
                    gain.gain.setValueAtTime(volume * 0.5, now + 0.8);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);

                    lfo.start(now);
                    osc1.start(now);
                    osc2.start(now);
                    osc3.start(now);
                    noise.start(now);
                    lfo.stop(now + 1.5);
                    osc1.stop(now + 1.5);
                    osc2.stop(now + 1.5);
                    osc3.stop(now + 1.5);
                    noise.stop(now + 1.5);
                    break;
                }
                case 'teleport': {
                    // Mystical whoosh with sparkle
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const noise = createNoise(0.2);
                    const filter = audioCtx.createBiquadFilter();
                    const noiseFilter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(3000, now);
                    filter.frequency.exponentialRampToValueAtTime(200, now + 0.2);
                    filter.Q.value = 5;

                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.setValueAtTime(4000, now);
                    noiseFilter.frequency.exponentialRampToValueAtTime(1000, now + 0.15);

                    osc1.type = 'sine';
                    osc2.type = 'triangle';
                    osc1.frequency.setValueAtTime(2500, now);
                    osc1.frequency.exponentialRampToValueAtTime(150, now + 0.2);
                    osc2.frequency.setValueAtTime(1800, now);
                    osc2.frequency.exponentialRampToValueAtTime(100, now + 0.18);

                    osc1.connect(filter);
                    osc2.connect(filter);
                    noise.connect(noiseFilter);
                    noiseFilter.connect(gain);
                    filter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(volume * 0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.22);

                    osc1.start(now);
                    osc2.start(now);
                    noise.start(now);
                    osc1.stop(now + 0.22);
                    osc2.stop(now + 0.2);
                    noise.stop(now + 0.2);
                    break;
                }
            }
        }

        // Game state
        let gameState = 'start';
        let score = 0;
        let souls = 0;
        let wave = 1;
        let enemiesRemaining = 0;
        let selectedClass = null;

        // Input
        const keys = {};
        let mouseX = W / 2;
        let mouseY = H / 2;
        let mouseDown = false;

        // Class definitions
        const classDefinitions = {
            mage: {
                name: 'Mage',
                color: '#9370db',
                secondaryColor: '#6a5acd',
                health: 80,
                speed: 4.5,
                fireRate: 180,
                bulletDamage: 15,
                bulletSpeed: 14,
                bulletSize: 6,
                bulletCount: 1,
                bulletPierce: 2,
                bulletRange: 600,
                tracking: 0,
                critChance: 0.05,
                critMultiplier: 2,
                damageReduction: 0,
                lifeRegen: 0,
                projectileType: 'magic',
                ability: 'arcaneNova',
                abilityName: 'Arcane Nova',
                abilityDesc: 'AoE magic burst',
                abilityCooldown: 8000,
                abilityDamage: 100,
                abilityRadius: 150
            },
            barbarian: {
                name: 'Barbarian',
                color: '#dc143c',
                secondaryColor: '#8b0000',
                health: 150,
                speed: 4,
                fireRate: 300,
                bulletDamage: 25,
                bulletSpeed: 10,
                bulletSize: 10,
                bulletCount: 1,
                bulletPierce: 1,
                bulletRange: 350,
                tracking: 0,
                critChance: 0.1,
                critMultiplier: 1.5,
                damageReduction: 0.1,
                lifeRegen: 0,
                projectileType: 'axe',
                ability: 'battleRage',
                abilityName: 'Battle Rage',
                abilityDesc: 'Damage & speed buff',
                abilityCooldown: 12000,
                abilityDuration: 5000,
                abilityDamageBuff: 0.5,
                abilitySpeedBuff: 0.3
            },
            ninja: {
                name: 'Ninja',
                color: '#5f9f9f',
                secondaryColor: '#2f4f4f',
                health: 90,
                speed: 7,
                fireRate: 120,
                bulletDamage: 8,
                bulletSpeed: 16,
                bulletSize: 4,
                bulletCount: 3,
                bulletPierce: 1,
                bulletRange: 450,
                tracking: 0,
                critChance: 0.25,
                critMultiplier: 2.5,
                damageReduction: 0,
                lifeRegen: 0,
                projectileType: 'shuriken',
                ability: 'shadowStep',
                abilityName: 'Shadow Step',
                abilityDesc: 'Dash with invincibility',
                abilityCooldown: 6000,
                abilityDistance: 200,
                abilityInvincibility: 500,
                abilityTrailDamage: 30
            },
            knight: {
                name: 'Knight',
                color: '#ffd700',
                secondaryColor: '#b8860b',
                health: 120,
                speed: 4.5,
                fireRate: 200,
                bulletDamage: 12,
                bulletSpeed: 12,
                bulletSize: 7,
                bulletCount: 1,
                bulletPierce: 1,
                bulletRange: 400,
                tracking: 0,
                critChance: 0.08,
                critMultiplier: 1.8,
                damageReduction: 0.2,
                lifeRegen: 0.5,
                projectileType: 'sword',
                ability: 'shieldWall',
                abilityName: 'Shield Wall',
                abilityDesc: 'Block & reflect damage',
                abilityCooldown: 10000,
                abilityDuration: 3000,
                abilityDamageReduction: 0.8,
                abilityReflect: 0.3
            }
        };

        // Class-specific upgrades
        const classUpgrades = {
            mage: [
                { id: 'arcaneBlast', name: 'Arcane Blast', desc: '+3 pierce & +5 damage', cost: 30, costMult: 1.8, level: 0, maxLevel: 8, apply: () => { player.bulletPierce += 3; player.bulletDamage += 5; } },
                { id: 'manaFlow', name: 'Mana Flow', desc: 'Shoot 15% faster', cost: 20, costMult: 1.5, level: 0, maxLevel: 10, apply: () => player.fireRate *= 0.85 },
                { id: 'spellSize', name: 'Spell Amplify', desc: '+4 projectile size', cost: 15, costMult: 1.4, level: 0, maxLevel: 10, apply: () => player.bulletSize += 4 }
            ],
            barbarian: [
                { id: 'rage', name: 'Berserker Rage', desc: '+20% damage when below 50% HP', cost: 25, costMult: 1.6, level: 0, maxLevel: 10, apply: () => player.rageDamage = (player.rageDamage || 0) + 0.2 },
                { id: 'cleave', name: 'Cleaving Axes', desc: '+2 pierce', cost: 35, costMult: 1.8, level: 0, maxLevel: 6, apply: () => player.bulletPierce += 2 },
                { id: 'warcry', name: 'War Cry', desc: '+30 max health', cost: 20, costMult: 1.4, level: 0, maxLevel: 15, apply: () => { player.maxHealth += 30; player.health += 30; } }
            ],
            ninja: [
                { id: 'swiftStrike', name: 'Swift Strike', desc: '+2 shurikens per attack', cost: 30, costMult: 2, level: 0, maxLevel: 6, apply: () => player.bulletCount += 2 },
                { id: 'deadlyPrecision', name: 'Deadly Precision', desc: '+10% crit, +0.5x crit damage', cost: 25, costMult: 1.6, level: 0, maxLevel: 8, apply: () => { player.critChance += 0.1; player.critMultiplier += 0.5; } },
                { id: 'shadowStep', name: 'Shadow Step', desc: '+1 speed', cost: 15, costMult: 1.5, level: 0, maxLevel: 10, apply: () => player.speed += 1 }
            ],
            knight: [
                { id: 'fortify', name: 'Fortify', desc: '+10% damage reduction', cost: 25, costMult: 1.6, level: 0, maxLevel: 8, apply: () => player.damageReduction += 0.1 },
                { id: 'holyBlade', name: 'Holy Blade', desc: '+8 damage, +1 HP/sec regen', cost: 30, costMult: 1.7, level: 0, maxLevel: 10, apply: () => { player.bulletDamage += 8; player.lifeRegen += 1; } },
                { id: 'shieldWall', name: 'Shield Wall', desc: '+40 max health', cost: 20, costMult: 1.4, level: 0, maxLevel: 12, apply: () => { player.maxHealth += 40; player.health += 40; } }
            ]
        };

        // Universal upgrades (available to all classes)
        const universalUpgrades = [
            { id: 'damage', name: 'Attack Power', desc: '+5 damage', cost: 10, costMult: 1.5, level: 0, maxLevel: 20, apply: () => player.bulletDamage += 5 },
            { id: 'fireRate', name: 'Attack Speed', desc: 'Shoot 8% faster', cost: 15, costMult: 1.4, level: 0, maxLevel: 15, apply: () => player.fireRate *= 0.92 },
            { id: 'bulletCount', name: 'Multi-Shot', desc: '+1 projectile', cost: 25, costMult: 2, level: 0, maxLevel: 8, apply: () => player.bulletCount += 1 },
            { id: 'tracking', name: 'Homing', desc: '+10% tracking', cost: 30, costMult: 1.6, level: 0, maxLevel: 10, apply: () => player.tracking += 0.1 },
            { id: 'stun', name: 'Stun Effect', desc: '+10% stun chance', cost: 20, costMult: 1.5, level: 0, maxLevel: 10, apply: () => player.stunChance = (player.stunChance || 0) + 0.1 },
            { id: 'explosive', name: 'Explosive', desc: '+8% explosion chance', cost: 40, costMult: 1.7, level: 0, maxLevel: 8, apply: () => player.explosiveChance = (player.explosiveChance || 0) + 0.08 },
            { id: 'vampiric', name: 'Life Steal', desc: '+2% life steal', cost: 50, costMult: 1.8, level: 0, maxLevel: 10, apply: () => player.vampiric = (player.vampiric || 0) + 0.02 },
            { id: 'maxHealth', name: 'Vitality', desc: '+20 max health', cost: 15, costMult: 1.4, level: 0, maxLevel: 20, apply: () => { player.maxHealth += 20; player.health += 20; } },
            { id: 'speed', name: 'Swiftness', desc: '+0.4 move speed', cost: 10, costMult: 1.3, level: 0, maxLevel: 15, apply: () => player.speed += 0.4 },
            { id: 'range', name: 'Extended Range', desc: '+50 projectile range', cost: 12, costMult: 1.3, level: 0, maxLevel: 12, apply: () => player.rangeBonus += 50 },
            { id: 'abilityPower', name: 'Ability Power', desc: '+15% ability effectiveness', cost: 35, costMult: 1.6, level: 0, maxLevel: 10, apply: () => player.abilityPower += 0.15 },
            { id: 'abilityCooldown', name: 'Ability Haste', desc: '-10% ability cooldown', cost: 30, costMult: 1.5, level: 0, maxLevel: 8, apply: () => player.abilityCooldownMult *= 0.9 },
            { id: 'abilityDuration', name: 'Ability Duration', desc: '+15% ability duration', cost: 25, costMult: 1.5, level: 0, maxLevel: 8, apply: () => player.abilityDurationMult += 0.15 }
        ];

        let currentUpgrades = [];

        // Player
        let player = {};

        function initPlayer(classType) {
            const classDef = classDefinitions[classType];
            player = {
                x: W / 2,
                y: H / 2,
                radius: 20,
                class: classType,
                ...classDef,
                maxHealth: classDef.health,
                invincible: 0,
                lastShot: 0,
                bulletSpread: 0.15,
                stunChance: 0,
                stunDuration: 500,
                explosiveChance: 0,
                explosiveRadius: 60,
                vampiric: 0,
                rageDamage: 0,
                // Ability state
                abilityCooldownEnd: 0,
                abilityActive: false,
                abilityActiveEnd: 0,
                // Ability upgrades (multiplicative modifiers)
                abilityPower: 1.0,
                abilityCooldownMult: 1.0,
                abilityDurationMult: 1.0,
                // Range upgrade
                rangeBonus: 0,
                // Battle Rage specific
                rageActive: false,
                rageDamageBonus: 0,
                rageSpeedBonus: 0,
                // Shield Wall specific
                shieldActive: false,
                shieldDamageReduction: 0,
                shieldReflect: 0
            };
        }

        // Bullets
        let bullets = [];
        const maxBullets = 2000;

        // Enemies - D&D and Mythology creatures
        let enemies = [];
        const enemyTypes = {
            goblin: {
                name: 'Goblin',
                radius: 14,
                speed: 2.5,
                health: 25,
                damage: 8,
                color: '#5a8a32',
                soulValue: 2
            },
            skeleton: {
                name: 'Skeleton',
                radius: 16,
                speed: 2,
                health: 30,
                damage: 10,
                color: '#e8e8d8',
                soulValue: 2
            },
            orc: {
                name: 'Orc',
                radius: 22,
                speed: 1.8,
                health: 60,
                damage: 15,
                color: '#4a6a2a',
                soulValue: 4
            },
            harpy: {
                name: 'Harpy',
                radius: 18,
                speed: 4,
                health: 35,
                damage: 12,
                color: '#8b668b',
                soulValue: 4
            },
            minotaur: {
                name: 'Minotaur',
                radius: 28,
                speed: 2.5,
                health: 100,
                damage: 25,
                color: '#6b4423',
                soulValue: 8
            },
            wraith: {
                name: 'Wraith',
                radius: 20,
                speed: 2.2,
                health: 45,
                damage: 15,
                color: 'rgba(100, 100, 150, 0.7)',
                soulValue: 5,
                special: 'phase'
            },
            basilisk: {
                name: 'Basilisk',
                radius: 24,
                speed: 1.5,
                health: 80,
                damage: 20,
                color: '#2d5a27',
                soulValue: 6
            },
            vampire: {
                name: 'Vampire',
                radius: 20,
                speed: 3,
                health: 70,
                damage: 18,
                color: '#4a0a2a',
                soulValue: 7,
                special: 'teleport'
            },
            lich: {
                name: 'Lich',
                radius: 22,
                speed: 1.5,
                health: 90,
                damage: 22,
                color: '#3a1a5a',
                soulValue: 10,
                special: 'summon'
            },
            cyclops: {
                name: 'Cyclops',
                radius: 35,
                speed: 1.2,
                health: 180,
                damage: 30,
                color: '#7a6a5a',
                soulValue: 15
            },
            hydra: {
                name: 'Hydra',
                radius: 40,
                speed: 1,
                health: 250,
                damage: 28,
                color: '#2a6a4a',
                soulValue: 20,
                special: 'regen'
            },
            dragon: {
                name: 'Dragon',
                radius: 50,
                speed: 1.5,
                health: 400,
                damage: 40,
                color: '#8b0000',
                soulValue: 35,
                special: 'fireBreath'
            },
            beholder: {
                name: 'Beholder',
                radius: 32,
                speed: 1.8,
                health: 140,
                damage: 22,
                color: '#8b4513',
                soulValue: 18,
                special: 'eyebeam'
            },
            golem: {
                name: 'Stone Golem',
                radius: 38,
                speed: 0.8,
                health: 300,
                damage: 35,
                color: '#696969',
                soulValue: 22
            },
            banshee: {
                name: 'Banshee',
                radius: 22,
                speed: 2.8,
                health: 55,
                damage: 18,
                color: '#e0e0ff',
                soulValue: 8,
                special: 'scream'
            },
            werewolf: {
                name: 'Werewolf',
                radius: 26,
                speed: 4.5,
                health: 85,
                damage: 22,
                color: '#4a4a4a',
                soulValue: 12
            },
            demon: {
                name: 'Demon',
                radius: 30,
                speed: 2.2,
                health: 160,
                damage: 28,
                color: '#8b0000',
                soulValue: 16,
                special: 'flames'
            },
            fireElemental: {
                name: 'Fire Elemental',
                radius: 28,
                speed: 2.5,
                health: 90,
                damage: 20,
                color: '#ff4500',
                soulValue: 11,
                special: 'burning'
            },
            troll: {
                name: 'Troll',
                radius: 34,
                speed: 1.4,
                health: 200,
                damage: 26,
                color: '#556b2f',
                soulValue: 14,
                special: 'regen'
            },
            medusa: {
                name: 'Medusa',
                radius: 24,
                speed: 1.6,
                health: 110,
                damage: 20,
                color: '#228b22',
                soulValue: 13,
                special: 'petrify'
            },
            griffin: {
                name: 'Griffin',
                radius: 30,
                speed: 3.5,
                health: 120,
                damage: 24,
                color: '#daa520',
                soulValue: 15
            },
            necromancer: {
                name: 'Necromancer',
                radius: 22,
                speed: 1.2,
                health: 70,
                damage: 15,
                color: '#2f1f4f',
                soulValue: 12,
                special: 'summon'
            }
        };

        // Particles
        let particles = [];

        // Initialize
        function init() {
            document.querySelectorAll('.class-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.class-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedClass = btn.dataset.class;
                    document.getElementById('startBtn').classList.add('enabled');
                };
            });

            document.getElementById('startBtn').onclick = startGame;
            document.getElementById('startWaveBtn').onclick = startWave;
            document.getElementById('restartBtn').onclick = restartGame;

            document.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if (e.code === 'Space' && gameState === 'playing') {
                    e.preventDefault();
                    activateAbility();
                }
            });
            document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            });
            canvas.addEventListener('mousedown', () => mouseDown = true);
            canvas.addEventListener('mouseup', () => mouseDown = false);

            gameLoop();
        }

        function startGame() {
            if (!selectedClass) return;
            initAudio();
            initPlayer(selectedClass);

            // Setup upgrades for this class
            currentUpgrades = [
                ...classUpgrades[selectedClass].map(u => ({...u})),
                ...universalUpgrades.map(u => ({...u}))
            ];

            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('classDisplay').textContent = `Class: ${classDefinitions[selectedClass].name}`;
            gameState = 'upgrading';
            showUpgradeMenu();
        }

        function restartGame() {
            score = 0;
            souls = 0;
            wave = 1;
            bullets = [];
            enemies = [];
            particles = [];
            selectedClass = null;

            document.querySelectorAll('.class-btn').forEach(b => b.classList.remove('selected'));
            document.getElementById('startBtn').classList.remove('enabled');
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            gameState = 'start';
        }

        function showUpgradeMenu() {
            const menu = document.getElementById('upgradeMenu');
            const grid = document.getElementById('upgradeGrid');
            document.getElementById('soulsDisplay').textContent = `Souls: ${souls}`;

            grid.innerHTML = '';
            currentUpgrades.forEach(upgrade => {
                const cost = Math.floor(upgrade.cost * Math.pow(upgrade.costMult, upgrade.level));
                const btn = document.createElement('button');
                btn.className = 'upgrade-btn';
                btn.disabled = souls < cost || upgrade.level >= upgrade.maxLevel;
                btn.innerHTML = `
                    <div class="name">${upgrade.name}</div>
                    <div class="desc">${upgrade.desc}</div>
                    <div class="cost">Cost: ${cost} souls</div>
                    <div class="level">Level: ${upgrade.level}/${upgrade.maxLevel}</div>
                `;
                btn.onclick = () => {
                    if (souls >= cost && upgrade.level < upgrade.maxLevel) {
                        souls -= cost;
                        upgrade.level++;
                        upgrade.apply();
                        playSound('upgrade');
                        showUpgradeMenu();
                    }
                };
                grid.appendChild(btn);
            });

            menu.style.display = 'block';
        }

        function startWave() {
            document.getElementById('upgradeMenu').style.display = 'none';
            gameState = 'playing';
            playSound('waveStart');
            spawnWave();
        }

        function getSpawnPosition() {
            let x, y;
            let attempts = 0;
            do {
                const side = Math.floor(Math.random() * 4);
                if (side === 0) { x = -30; y = Math.random() * H; }
                else if (side === 1) { x = W + 30; y = Math.random() * H; }
                else if (side === 2) { x = Math.random() * W; y = -30; }
                else { x = Math.random() * W; y = H + 30; }
                attempts++;
            } while (Math.hypot(x - player.x, y - player.y) < SPAWN_PROTECTION_RADIUS && attempts < 20);
            return { x, y };
        }

        function spawnWave() {
            const baseEnemies = 5 + wave * 3;
            const types = Object.keys(enemyTypes);

            for (let i = 0; i < baseEnemies; i++) {
                setTimeout(() => {
                    if (gameState !== 'playing') return;

                    let typeIndex = Math.floor(Math.random() * Math.min(wave + 1, types.length));
                    const type = types[typeIndex];
                    const template = enemyTypes[type];

                    const pos = getSpawnPosition();
                    const healthMult = 1 + (wave - 1) * 0.15;

                    enemies.push({
                        x: pos.x,
                        y: pos.y,
                        type,
                        radius: template.radius,
                        speed: template.speed,
                        health: template.health * healthMult,
                        maxHealth: template.health * healthMult,
                        damage: template.damage,
                        color: template.color,
                        soulValue: template.soulValue,
                        special: template.special,
                        stunned: 0,
                        teleportCooldown: 0,
                        phaseTimer: 0,
                        summonCooldown: 0,
                        regenTimer: 0
                    });
                    enemiesRemaining++;
                }, i * 300);
            }

            // Boss every 5 waves
            if (wave % 5 === 0) {
                setTimeout(() => {
                    if (gameState !== 'playing') return;
                    playSound('bossSpawn');
                    const bossHealth = 600 * wave;
                    const pos = getSpawnPosition();
                    enemies.push({
                        x: pos.x,
                        y: pos.y,
                        type: 'dragon',
                        radius: 60 + wave * 2,
                        speed: 0.8,
                        health: bossHealth,
                        maxHealth: bossHealth,
                        damage: 50,
                        color: '#8b0000',
                        soulValue: 50 + wave * 10,
                        special: 'fireBreath',
                        isBoss: true,
                        stunned: 0
                    });
                    enemiesRemaining++;
                }, baseEnemies * 300 + 1000);
            }
        }

        function shoot() {
            const now = Date.now();
            if (now - player.lastShot < player.fireRate) return;
            player.lastShot = now;

            playSound('shoot');

            const baseAngle = Math.atan2(mouseY - player.y, mouseX - player.x);

            // Calculate rage bonus (passive Berserker Rage upgrade + active Battle Rage ability)
            let damageMultiplier = 1;
            if (player.rageDamage && player.health < player.maxHealth * 0.5) {
                damageMultiplier += player.rageDamage;
            }
            if (player.rageActive && player.rageDamageBonus > 0) {
                damageMultiplier += player.rageDamageBonus;
            }

            for (let i = 0; i < player.bulletCount; i++) {
                if (bullets.length >= maxBullets) bullets.shift();

                const spreadAngle = (i - (player.bulletCount - 1) / 2) * player.bulletSpread;
                const angle = baseAngle + spreadAngle + (Math.random() - 0.5) * 0.05;

                const isCrit = Math.random() < player.critChance;

                bullets.push({
                    x: player.x,
                    y: player.y,
                    startX: player.x,
                    startY: player.y,
                    vx: Math.cos(angle) * player.bulletSpeed,
                    vy: Math.sin(angle) * player.bulletSpeed,
                    radius: player.bulletSize,
                    damage: player.bulletDamage * damageMultiplier * (isCrit ? player.critMultiplier : 1),
                    pierce: player.bulletPierce,
                    isCrit,
                    tracking: player.tracking,
                    stun: Math.random() < (player.stunChance || 0),
                    explosive: Math.random() < (player.explosiveChance || 0),
                    type: player.projectileType,
                    angle: angle,
                    maxRange: player.bulletRange + player.rangeBonus
                });
            }
        }

        function activateAbility() {
            const now = Date.now();

            // Check cooldown
            if (now < player.abilityCooldownEnd) {
                return;
            }

            const classDef = classDefinitions[player.class];
            const cooldown = classDef.abilityCooldown * player.abilityCooldownMult;

            switch(classDef.ability) {
                case 'arcaneNova': {
                    // Mage: AoE magic explosion around player
                    const radius = classDef.abilityRadius * player.abilityPower;
                    const damage = classDef.abilityDamage * player.abilityPower;

                    playSound('explosion');

                    // Create visual effect
                    for (let i = 0; i < 30; i++) {
                        const angle = (i / 30) * Math.PI * 2;
                        for (let d = 0; d < 3; d++) {
                            particles.push({
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(angle) * (3 + d * 2),
                                vy: Math.sin(angle) * (3 + d * 2),
                                radius: 8 - d * 2,
                                color: d === 0 ? '#00ffff' : d === 1 ? '#9370db' : '#ff00ff',
                                life: 30 + d * 10
                            });
                        }
                    }

                    // Damage all enemies in radius
                    for (const e of enemies) {
                        const dist = Math.hypot(e.x - player.x, e.y - player.y);
                        if (dist < radius) {
                            e.health -= damage;
                            e.stunned = now + 500;
                            if (e.health <= 0) {
                                score += e.soulValue * 10;
                                souls += e.soulValue;
                                playSound('kill');
                            }
                        }
                    }

                    // Store nova effect for drawing
                    player.novaEffect = { radius: radius, time: now };
                    break;
                }

                case 'battleRage': {
                    // Barbarian: Temporary damage and speed buff
                    const duration = classDef.abilityDuration * player.abilityDurationMult;
                    const damageBuff = classDef.abilityDamageBuff * player.abilityPower;
                    const speedBuff = classDef.abilitySpeedBuff * player.abilityPower;

                    playSound('bossSpawn');

                    player.rageActive = true;
                    player.rageDamageBonus = damageBuff;
                    player.rageSpeedBonus = speedBuff;
                    player.abilityActiveEnd = now + duration;

                    // Visual effect - red particles burst
                    for (let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        particles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * (2 + Math.random() * 3),
                            vy: Math.sin(angle) * (2 + Math.random() * 3),
                            radius: 6 + Math.random() * 4,
                            color: '#ff4444',
                            life: 40
                        });
                    }
                    break;
                }

                case 'shadowStep': {
                    // Ninja: Dash in movement direction with invincibility
                    const distance = classDef.abilityDistance * player.abilityPower;
                    const invincTime = classDef.abilityInvincibility * player.abilityDurationMult;
                    const trailDamage = classDef.abilityTrailDamage * player.abilityPower;

                    playSound('teleport');

                    // Determine dash direction from movement keys or mouse
                    let dx = 0, dy = 0;
                    if (keys['w'] || keys['arrowup']) dy -= 1;
                    if (keys['s'] || keys['arrowdown']) dy += 1;
                    if (keys['a'] || keys['arrowleft']) dx -= 1;
                    if (keys['d'] || keys['arrowright']) dx += 1;

                    // If no movement keys, dash toward mouse
                    if (dx === 0 && dy === 0) {
                        dx = mouseX - player.x;
                        dy = mouseY - player.y;
                    }

                    const len = Math.hypot(dx, dy);
                    if (len > 0) {
                        dx /= len;
                        dy /= len;
                    }

                    const startX = player.x;
                    const startY = player.y;

                    // Move player
                    player.x = Math.max(player.radius, Math.min(W - player.radius, player.x + dx * distance));
                    player.y = Math.max(player.radius, Math.min(H - player.radius, player.y + dy * distance));

                    // Create trail effect and damage enemies along path
                    const trailSteps = 10;
                    for (let i = 0; i <= trailSteps; i++) {
                        const t = i / trailSteps;
                        const tx = startX + (player.x - startX) * t;
                        const ty = startY + (player.y - startY) * t;

                        // Trail particles
                        for (let j = 0; j < 3; j++) {
                            particles.push({
                                x: tx + (Math.random() - 0.5) * 20,
                                y: ty + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 2,
                                vy: (Math.random() - 0.5) * 2,
                                radius: 5 + Math.random() * 5,
                                color: '#5f9f9f',
                                life: 20 + Math.random() * 20
                            });
                        }

                        // Damage enemies along trail
                        for (const e of enemies) {
                            const dist = Math.hypot(e.x - tx, e.y - ty);
                            if (dist < 40 && !e.trailHit) {
                                e.health -= trailDamage;
                                e.trailHit = true;
                                if (e.health <= 0) {
                                    score += e.soulValue * 10;
                                    souls += e.soulValue;
                                    playSound('kill');
                                }
                            }
                        }
                    }

                    // Reset trail hit flags
                    for (const e of enemies) {
                        e.trailHit = false;
                    }

                    // Grant invincibility
                    player.invincible = now + invincTime;
                    break;
                }

                case 'shieldWall': {
                    // Knight: Damage reduction and reflect
                    const duration = classDef.abilityDuration * player.abilityDurationMult;
                    const damageReduction = classDef.abilityDamageReduction * player.abilityPower;
                    const reflect = classDef.abilityReflect * player.abilityPower;

                    playSound('upgrade');

                    player.shieldActive = true;
                    player.shieldDamageReduction = damageReduction;
                    player.shieldReflect = reflect;
                    player.abilityActiveEnd = now + duration;

                    // Visual effect - golden shield particles
                    for (let i = 0; i < 16; i++) {
                        const angle = (i / 16) * Math.PI * 2;
                        particles.push({
                            x: player.x + Math.cos(angle) * 30,
                            y: player.y + Math.sin(angle) * 30,
                            vx: Math.cos(angle) * 0.5,
                            vy: Math.sin(angle) * 0.5,
                            radius: 6,
                            color: '#ffd700',
                            life: 30
                        });
                    }
                    break;
                }
            }

            // Set cooldown
            player.abilityCooldownEnd = now + cooldown;
        }

        function updateAbilities() {
            const now = Date.now();

            // Update Battle Rage
            if (player.rageActive && now >= player.abilityActiveEnd) {
                player.rageActive = false;
                player.rageDamageBonus = 0;
                player.rageSpeedBonus = 0;
            }

            // Update Shield Wall
            if (player.shieldActive && now >= player.abilityActiveEnd) {
                player.shieldActive = false;
                player.shieldDamageReduction = 0;
                player.shieldReflect = 0;
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];

                // Tracking
                if (b.tracking > 0 && enemies.length > 0) {
                    let closest = null;
                    let closestDist = Infinity;
                    for (const e of enemies) {
                        const dist = Math.hypot(e.x - b.x, e.y - b.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closest = e;
                        }
                    }
                    if (closest) {
                        const targetAngle = Math.atan2(closest.y - b.y, closest.x - b.x);
                        const currentAngle = Math.atan2(b.vy, b.vx);
                        let angleDiff = targetAngle - currentAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        const newAngle = currentAngle + angleDiff * b.tracking * 0.1;
                        const speed = Math.hypot(b.vx, b.vy);
                        b.vx = Math.cos(newAngle) * speed;
                        b.vy = Math.sin(newAngle) * speed;
                        b.angle = newAngle;
                    }
                }

                b.x += b.vx;
                b.y += b.vy;

                // Check if bullet exceeded its range
                const travelDist = Math.hypot(b.x - b.startX, b.y - b.startY);
                if (travelDist > b.maxRange) {
                    // Fade out particle
                    particles.push({
                        x: b.x,
                        y: b.y,
                        vx: 0,
                        vy: 0,
                        radius: b.radius * 0.8,
                        color: classDefinitions[player.class]?.color || '#888',
                        life: 10
                    });
                    bullets.splice(i, 1);
                    continue;
                }

                if (b.x < -50 || b.x > W + 50 || b.y < -50 || b.y > H + 50) {
                    bullets.splice(i, 1);
                    continue;
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    const dist = Math.hypot(e.x - b.x, e.y - b.y);

                    if (e.special === 'phase' && e.phaseTimer > 0) continue;

                    if (dist < e.radius + b.radius) {
                        e.health -= b.damage;
                        playSound('hit');

                        if (b.stun) {
                            e.stunned = Date.now() + player.stunDuration;
                        }

                        if (b.explosive) {
                            createExplosion(b.x, b.y);
                            playSound('explosion');
                            for (const e2 of enemies) {
                                if (e2 !== e && Math.hypot(e2.x - b.x, e2.y - b.y) < player.explosiveRadius) {
                                    e2.health -= b.damage * 0.5;
                                }
                            }
                        }

                        if (player.vampiric > 0) {
                            player.health = Math.min(player.maxHealth, player.health + b.damage * player.vampiric);
                        }

                        for (let p = 0; p < 3; p++) {
                            particles.push({
                                x: b.x,
                                y: b.y,
                                vx: (Math.random() - 0.5) * 5,
                                vy: (Math.random() - 0.5) * 5,
                                life: 20,
                                color: b.isCrit ? '#ffff00' : '#ff6600',
                                radius: b.isCrit ? 4 : 2
                            });
                        }

                        if (e.health <= 0) {
                            score += e.soulValue * 10;
                            souls += e.soulValue;
                            enemiesRemaining--;
                            playSound('kill');

                            for (let p = 0; p < 15; p++) {
                                particles.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: (Math.random() - 0.5) * 8,
                                    vy: (Math.random() - 0.5) * 8,
                                    life: 40,
                                    color: e.color,
                                    radius: 5
                                });
                            }

                            enemies.splice(j, 1);
                        }

                        b.pierce--;
                        if (b.pierce <= 0) {
                            bullets.splice(i, 1);
                        }
                        break;
                    }
                }
            }
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                particles.push({
                    x,
                    y,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    life: 25,
                    color: '#ff4400',
                    radius: 6
                });
            }
        }

        function updateEnemies() {
            const now = Date.now();

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];

                if (e.stunned > now) continue;

                // Special behaviors
                if (e.special === 'teleport' && e.teleportCooldown < now) {
                    if (Math.random() < 0.01) {
                        const newPos = getSpawnPosition();
                        e.x = player.x + (Math.random() - 0.5) * 250;
                        e.y = player.y + (Math.random() - 0.5) * 250;
                        e.x = Math.max(50, Math.min(W - 50, e.x));
                        e.y = Math.max(50, Math.min(H - 50, e.y));
                        e.teleportCooldown = now + 2000;
                        playSound('teleport');
                        for (let p = 0; p < 10; p++) {
                            particles.push({
                                x: e.x, y: e.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 20,
                                color: '#8b008b',
                                radius: 3
                            });
                        }
                    }
                }

                if (e.special === 'phase') {
                    if (e.phaseTimer <= 0 && Math.random() < 0.005) {
                        e.phaseTimer = 60;
                    }
                    if (e.phaseTimer > 0) e.phaseTimer--;
                }

                if (e.special === 'summon' && e.summonCooldown < now) {
                    if (Math.random() < 0.005) {
                        const template = enemyTypes.skeleton;
                        const pos = { x: e.x + (Math.random() - 0.5) * 60, y: e.y + (Math.random() - 0.5) * 60 };
                        enemies.push({
                            x: pos.x,
                            y: pos.y,
                            type: 'skeleton',
                            ...template,
                            health: template.health,
                            maxHealth: template.health,
                            stunned: 0,
                            phaseTimer: 0,
                            teleportCooldown: 0,
                            summonCooldown: 0
                        });
                        enemiesRemaining++;
                        e.summonCooldown = now + 3000;
                    }
                }

                if (e.special === 'regen') {
                    e.regenTimer = (e.regenTimer || 0) + 1;
                    if (e.regenTimer >= 30) {
                        e.health = Math.min(e.maxHealth, e.health + e.maxHealth * 0.02);
                        e.regenTimer = 0;
                    }
                }

                // Move toward player
                const angle = Math.atan2(player.y - e.y, player.x - e.x);
                e.x += Math.cos(angle) * e.speed;
                e.y += Math.sin(angle) * e.speed;

                // Collision with player
                const dist = Math.hypot(player.x - e.x, player.y - e.y);
                if (dist < player.radius + e.radius && player.invincible < now) {
                    // Apply damage reduction (passive + shield wall)
                    const totalDamageReduction = Math.min(0.95, player.damageReduction + (player.shieldActive ? player.shieldDamageReduction : 0));
                    let damage = e.damage * (1 - totalDamageReduction);
                    player.health -= damage;
                    player.invincible = now + 500;
                    playSound('playerHit');

                    // Shield Wall reflect damage
                    if (player.shieldActive && player.shieldReflect > 0) {
                        const reflectDamage = e.damage * player.shieldReflect;
                        e.health -= reflectDamage;
                        // Visual feedback for reflect
                        for (let p = 0; p < 5; p++) {
                            particles.push({
                                x: e.x,
                                y: e.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 20,
                                color: '#ffd700',
                                radius: 5
                            });
                        }
                        if (e.health <= 0) {
                            score += e.soulValue * 10;
                            souls += e.soulValue;
                            playSound('kill');
                        }
                    }

                    const knockAngle = Math.atan2(player.y - e.y, player.x - e.x);
                    player.x += Math.cos(knockAngle) * 30;
                    player.y += Math.sin(knockAngle) * 30;

                    for (let p = 0; p < 10; p++) {
                        particles.push({
                            x: player.x,
                            y: player.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            life: 30,
                            color: player.shieldActive ? '#ffd700' : '#ff0000',
                            radius: 4
                        });
                    }
                }
            }
        }

        function updatePlayer() {
            // Life regen
            if (player.lifeRegen > 0) {
                player.health = Math.min(player.maxHealth, player.health + player.lifeRegen / 60);
            }

            // Movement
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy -= 1;
            if (keys['s'] || keys['arrowdown']) dy += 1;
            if (keys['a'] || keys['arrowleft']) dx -= 1;
            if (keys['d'] || keys['arrowright']) dx += 1;

            if (dx !== 0 || dy !== 0) {
                const len = Math.hypot(dx, dy);
                const speedMult = 1 + (player.rageActive ? player.rageSpeedBonus : 0);
                player.x += (dx / len) * player.speed * speedMult;
                player.y += (dy / len) * player.speed * speedMult;
            }

            player.x = Math.max(player.radius, Math.min(W - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(H - player.radius, player.y));

            if (mouseDown) {
                shoot();
            }

            if (player.health <= 0) {
                gameState = 'gameover';
                playSound('gameOver');
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('finalScore').textContent = `Final Score: ${score}`;
                document.getElementById('finalWave').textContent = `Reached Wave: ${wave}`;
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawPlayer() {
            ctx.save();

            if (player.invincible > Date.now() && Math.floor(Date.now() / 50) % 2) {
                ctx.globalAlpha = 0.5;
            }

            const classDef = classDefinitions[player.class];

            // Draw based on class
            switch(player.class) {
                case 'mage':
                    // Robe body
                    ctx.fillStyle = classDef.secondaryColor;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Hood
                    ctx.fillStyle = classDef.color;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y - 5, player.radius * 0.7, Math.PI, 0);
                    ctx.fill();
                    // Staff glow
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(player.x + 15, player.y - 15, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ffff';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;

                case 'barbarian':
                    // Muscular body
                    ctx.fillStyle = '#d4a574';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // War paint
                    ctx.strokeStyle = classDef.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(player.x - 10, player.y - 5);
                    ctx.lineTo(player.x - 5, player.y);
                    ctx.lineTo(player.x - 10, player.y + 5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(player.x + 10, player.y - 5);
                    ctx.lineTo(player.x + 5, player.y);
                    ctx.lineTo(player.x + 10, player.y + 5);
                    ctx.stroke();
                    // Mohawk
                    ctx.fillStyle = classDef.secondaryColor;
                    for (let i = -2; i <= 2; i++) {
                        ctx.fillRect(player.x + i * 4 - 2, player.y - player.radius - 8, 4, 10);
                    }
                    break;

                case 'ninja':
                    // Body
                    ctx.fillStyle = classDef.secondaryColor;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Mask
                    ctx.fillStyle = classDef.color;
                    ctx.fillRect(player.x - 12, player.y - 8, 24, 8);
                    // Eyes
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(player.x - 8, player.y - 6, 5, 3);
                    ctx.fillRect(player.x + 3, player.y - 6, 5, 3);
                    // Headband tails
                    ctx.strokeStyle = classDef.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(player.x + 12, player.y - 5);
                    ctx.quadraticCurveTo(player.x + 25, player.y - 10, player.x + 20, player.y + 5);
                    ctx.stroke();
                    break;

                case 'knight':
                    // Armor body
                    ctx.fillStyle = '#888';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Helmet
                    ctx.fillStyle = classDef.secondaryColor;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y - 5, player.radius * 0.8, Math.PI, 0);
                    ctx.fill();
                    // Visor slit
                    ctx.fillStyle = '#222';
                    ctx.fillRect(player.x - 10, player.y - 8, 20, 4);
                    // Plume
                    ctx.fillStyle = classDef.color;
                    ctx.beginPath();
                    ctx.ellipse(player.x, player.y - player.radius - 5, 4, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }

            // Eyes looking at mouse (for mage and barbarian)
            if (player.class === 'mage' || player.class === 'barbarian') {
                const eyeAngle = Math.atan2(mouseY - player.y, mouseX - player.x);
                const eyeOffsetX = Math.cos(eyeAngle) * 2;
                const eyeOffsetY = Math.sin(eyeAngle) * 2;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(player.x - 5, player.y - 3, 3, 0, Math.PI * 2);
                ctx.arc(player.x + 5, player.y - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(player.x - 5 + eyeOffsetX, player.y - 3 + eyeOffsetY, 1.5, 0, Math.PI * 2);
                ctx.arc(player.x + 5 + eyeOffsetX, player.y - 3 + eyeOffsetY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawEnemy(e) {
            ctx.save();
            ctx.translate(e.x, e.y);

            // Calculate angle toward player for facing direction
            const angle = Math.atan2(player.y - e.y, player.x - e.x);

            if (e.special === 'phase' && e.phaseTimer > 0) {
                ctx.globalAlpha = 0.3;
            }

            const isStunned = e.stunned > Date.now();
            const r = e.radius;

            switch(e.type) {
                case 'goblin':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#5a8a32';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r * 0.8, r, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Big ears
                    ctx.fillStyle = isStunned ? '#99e' : '#4a7a22';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.9, -r * 0.3, r * 0.4, r * 0.6, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(r * 0.9, -r * 0.3, r * 0.4, r * 0.6, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.2, r * 0.2, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.2, r * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.2, r * 0.1, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.2, r * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    // Big nose
                    ctx.fillStyle = isStunned ? '#88c' : '#3a6a12';
                    ctx.beginPath();
                    ctx.arc(0, r * 0.1, r * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    // Mouth
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, r * 0.4, r * 0.3, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                    break;

                case 'skeleton':
                    // Skull
                    ctx.fillStyle = isStunned ? '#aaf' : '#e8e8d8';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.1, r * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    // Jaw
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.4, r * 0.5, r * 0.35, 0, 0, Math.PI);
                    ctx.fill();
                    // Eye sockets
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.25, -r * 0.2, r * 0.2, r * 0.25, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.25, -r * 0.2, r * 0.2, r * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Glowing eyes
                    ctx.fillStyle = '#f44';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.2, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.2, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose hole
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(0, r * 0.05);
                    ctx.lineTo(-r * 0.1, r * 0.2);
                    ctx.lineTo(r * 0.1, r * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    // Teeth
                    ctx.fillStyle = isStunned ? '#aaf' : '#e8e8d8';
                    for (let i = -2; i <= 2; i++) {
                        ctx.fillRect(i * r * 0.15 - r * 0.05, r * 0.25, r * 0.1, r * 0.15);
                    }
                    break;

                case 'orc':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#4a6a2a';
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Brow ridge
                    ctx.fillStyle = isStunned ? '#99e' : '#3a5a1a';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.4, r * 0.8, r * 0.3, 0, Math.PI, 0);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(-r * 0.3, -r * 0.15, r * 0.15, 0, Math.PI * 2);
                    ctx.arc(r * 0.3, -r * 0.15, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.3, -r * 0.15, r * 0.07, 0, Math.PI * 2);
                    ctx.arc(r * 0.3, -r * 0.15, r * 0.07, 0, Math.PI * 2);
                    ctx.fill();
                    // Tusks
                    ctx.fillStyle = '#fffff0';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.4, r * 0.2);
                    ctx.lineTo(-r * 0.5, -r * 0.2);
                    ctx.lineTo(-r * 0.25, r * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.4, r * 0.2);
                    ctx.lineTo(r * 0.5, -r * 0.2);
                    ctx.lineTo(r * 0.25, r * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    // Nose
                    ctx.fillStyle = isStunned ? '#88c' : '#2a4a0a';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.15, r * 0.2, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'harpy':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#8b668b';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r * 0.6, r * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Wings
                    ctx.fillStyle = isStunned ? '#99e' : '#6b466b';
                    const wingFlap = Math.sin(Date.now() / 80) * 0.3;
                    ctx.save();
                    ctx.rotate(-0.5 + wingFlap);
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.8, 0, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    ctx.save();
                    ctx.rotate(0.5 - wingFlap);
                    ctx.beginPath();
                    ctx.ellipse(r * 0.8, 0, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    // Face
                    ctx.fillStyle = '#dbb';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(-r * 0.15, -r * 0.35, r * 0.1, 0, Math.PI * 2);
                    ctx.arc(r * 0.15, -r * 0.35, r * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    // Beak
                    ctx.fillStyle = '#fa0';
                    ctx.beginPath();
                    ctx.moveTo(0, -r * 0.2);
                    ctx.lineTo(-r * 0.1, -r * 0.05);
                    ctx.lineTo(r * 0.1, -r * 0.05);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case 'minotaur':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#6b4423';
                    ctx.beginPath();
                    ctx.arc(0, r * 0.1, r * 0.85, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.3, r * 0.6, r * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Horns
                    ctx.fillStyle = isStunned ? '#ddd' : '#fffff0';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.5, -r * 0.5);
                    ctx.quadraticCurveTo(-r * 0.9, -r * 0.9, -r * 0.7, -r * 1.1);
                    ctx.quadraticCurveTo(-r * 0.5, -r * 0.8, -r * 0.3, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.5, -r * 0.5);
                    ctx.quadraticCurveTo(r * 0.9, -r * 0.9, r * 0.7, -r * 1.1);
                    ctx.quadraticCurveTo(r * 0.5, -r * 0.8, r * 0.3, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    // Snout
                    ctx.fillStyle = isStunned ? '#99e' : '#5b3413';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.1, r * 0.35, r * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Nostrils
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(-r * 0.12, -r * 0.05, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.12, -r * 0.05, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.4, r * 0.12, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.4, r * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose ring
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, r * 0.05, r * 0.15, 0.3, Math.PI - 0.3);
                    ctx.stroke();
                    break;

                case 'wraith':
                    // Ghostly body
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                    gradient.addColorStop(0, isStunned ? 'rgba(150,150,255,0.8)' : 'rgba(100,100,150,0.8)');
                    gradient.addColorStop(1, 'rgba(50,50,80,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Tattered cloak shape
                    ctx.fillStyle = isStunned ? 'rgba(150,150,255,0.6)' : 'rgba(60,60,100,0.7)';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.6, -r * 0.5);
                    ctx.quadraticCurveTo(0, -r * 0.8, r * 0.6, -r * 0.5);
                    ctx.lineTo(r * 0.8, r * 0.8);
                    ctx.quadraticCurveTo(r * 0.4, r * 0.6, 0, r);
                    ctx.quadraticCurveTo(-r * 0.4, r * 0.6, -r * 0.8, r * 0.8);
                    ctx.closePath();
                    ctx.fill();
                    // Glowing eyes
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0ff';
                    ctx.fillStyle = '#0ff';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.2, r * 0.12, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.2, r * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;

                case 'basilisk':
                    // Snake body
                    ctx.fillStyle = isStunned ? '#aaf' : '#2d5a27';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r, r * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Scales pattern
                    ctx.fillStyle = isStunned ? '#99e' : '#1d4a17';
                    for (let i = -2; i <= 2; i++) {
                        for (let j = -1; j <= 1; j++) {
                            ctx.beginPath();
                            ctx.arc(i * r * 0.3, j * r * 0.25, r * 0.12, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    // Head
                    ctx.fillStyle = isStunned ? '#aaf' : '#2d5a27';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.4, r * 0.5, r * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Crown/crest
                    ctx.fillStyle = '#f44';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.2, -r * 0.7);
                    ctx.lineTo(0, -r * 1);
                    ctx.lineTo(r * 0.2, -r * 0.7);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.2, -r * 0.45, r * 0.12, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.2, -r * 0.45, r * 0.12, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.2, -r * 0.45, r * 0.04, r * 0.1, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.2, -r * 0.45, r * 0.04, r * 0.1, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Tongue
                    ctx.strokeStyle = '#f44';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -r * 0.2);
                    ctx.lineTo(0, -r * 0.05);
                    ctx.lineTo(-r * 0.1, r * 0.1);
                    ctx.moveTo(0, -r * 0.05);
                    ctx.lineTo(r * 0.1, r * 0.1);
                    ctx.stroke();
                    break;

                case 'vampire':
                    // Cape
                    ctx.fillStyle = isStunned ? '#66a' : '#2a0a2a';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.3, -r * 0.5);
                    ctx.quadraticCurveTo(-r * 1.1, 0, -r * 0.9, r * 0.9);
                    ctx.lineTo(0, r * 0.6);
                    ctx.lineTo(r * 0.9, r * 0.9);
                    ctx.quadraticCurveTo(r * 1.1, 0, r * 0.3, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#4a0a2a';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r * 0.5, r * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Face
                    ctx.fillStyle = '#ddd';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.25, r * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Hair
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.35, r * 0.4, Math.PI, 0);
                    ctx.fill();
                    // Widow's peak
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.2, -r * 0.5);
                    ctx.lineTo(0, -r * 0.25);
                    ctx.lineTo(r * 0.2, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(-r * 0.15, -r * 0.3, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.15, -r * 0.3, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Fangs
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.1, -r * 0.05);
                    ctx.lineTo(-r * 0.05, r * 0.15);
                    ctx.lineTo(0, -r * 0.05);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(0, -r * 0.05);
                    ctx.lineTo(r * 0.05, r * 0.15);
                    ctx.lineTo(r * 0.1, -r * 0.05);
                    ctx.fill();
                    break;

                case 'lich':
                    // Robe
                    ctx.fillStyle = isStunned ? '#66a' : '#2a1a4a';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.5, -r * 0.3);
                    ctx.lineTo(-r * 0.8, r);
                    ctx.lineTo(r * 0.8, r);
                    ctx.lineTo(r * 0.5, -r * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    // Skull face
                    ctx.fillStyle = isStunned ? '#ccf' : '#c0c0a0';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.2, r * 0.45, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye sockets with glow
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.18, -r * 0.25, r * 0.15, 0, Math.PI * 2);
                    ctx.arc(r * 0.18, -r * 0.25, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#a0f';
                    ctx.fillStyle = '#a0f';
                    ctx.beginPath();
                    ctx.arc(-r * 0.18, -r * 0.25, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.18, -r * 0.25, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Crown
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.35, -r * 0.55);
                    ctx.lineTo(-r * 0.25, -r * 0.85);
                    ctx.lineTo(-r * 0.1, -r * 0.6);
                    ctx.lineTo(0, -r * 0.9);
                    ctx.lineTo(r * 0.1, -r * 0.6);
                    ctx.lineTo(r * 0.25, -r * 0.85);
                    ctx.lineTo(r * 0.35, -r * 0.55);
                    ctx.closePath();
                    ctx.fill();
                    // Staff
                    ctx.strokeStyle = '#4a3a2a';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(r * 0.6, -r * 0.4);
                    ctx.lineTo(r * 0.6, r * 0.8);
                    ctx.stroke();
                    ctx.fillStyle = '#a0f';
                    ctx.beginPath();
                    ctx.arc(r * 0.6, -r * 0.5, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'cyclops':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#7a6a5a';
                    ctx.beginPath();
                    ctx.arc(0, r * 0.1, r * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    // One big eye
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#840';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    // Brow
                    ctx.fillStyle = isStunned ? '#99e' : '#5a4a3a';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.55, r * 0.5, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Mouth
                    ctx.fillStyle = '#3a2a1a';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.2, r * 0.3, r * 0.15, 0, 0, Math.PI);
                    ctx.fill();
                    // Teeth
                    ctx.fillStyle = '#ff9';
                    for (let i = -2; i <= 2; i++) {
                        ctx.fillRect(i * r * 0.12 - r * 0.04, r * 0.1, r * 0.08, r * 0.12);
                    }
                    break;

                case 'hydra':
                    // Main body
                    ctx.fillStyle = isStunned ? '#aaf' : '#2a6a4a';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.2, r * 0.7, r * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Multiple heads (3)
                    const headPositions = [
                        {x: -r * 0.5, y: -r * 0.5, rot: -0.3},
                        {x: 0, y: -r * 0.7, rot: 0},
                        {x: r * 0.5, y: -r * 0.5, rot: 0.3}
                    ];
                    for (const head of headPositions) {
                        ctx.save();
                        ctx.translate(head.x, head.y);
                        ctx.rotate(head.rot);
                        // Neck
                        ctx.fillStyle = isStunned ? '#aaf' : '#2a6a4a';
                        ctx.beginPath();
                        ctx.ellipse(0, r * 0.2, r * 0.15, r * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Head
                        ctx.beginPath();
                        ctx.ellipse(0, -r * 0.1, r * 0.25, r * 0.2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Eyes
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(-r * 0.1, -r * 0.15, r * 0.06, 0, Math.PI * 2);
                        ctx.arc(r * 0.1, -r * 0.15, r * 0.06, 0, Math.PI * 2);
                        ctx.fill();
                        // Teeth
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.moveTo(-r * 0.1, 0);
                        ctx.lineTo(-r * 0.05, r * 0.1);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(r * 0.05, r * 0.1);
                        ctx.lineTo(r * 0.1, 0);
                        ctx.fill();
                        ctx.restore();
                    }
                    break;

                case 'dragon':
                    // Wings
                    ctx.fillStyle = isStunned ? '#88a' : '#6a0000';
                    const wingFlap2 = Math.sin(Date.now() / 100) * 0.2;
                    ctx.save();
                    ctx.rotate(-0.4 + wingFlap2);
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.3, 0);
                    ctx.quadraticCurveTo(-r * 1.2, -r * 0.5, -r * 1.3, r * 0.2);
                    ctx.quadraticCurveTo(-r * 0.8, r * 0.1, -r * 0.3, 0);
                    ctx.fill();
                    ctx.restore();
                    ctx.save();
                    ctx.rotate(0.4 - wingFlap2);
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, 0);
                    ctx.quadraticCurveTo(r * 1.2, -r * 0.5, r * 1.3, r * 0.2);
                    ctx.quadraticCurveTo(r * 0.8, r * 0.1, r * 0.3, 0);
                    ctx.fill();
                    ctx.restore();
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#8b0000';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.1, r * 0.6, r * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.5, r * 0.45, r * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Horns
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.35, -r * 0.7);
                    ctx.lineTo(-r * 0.5, -r * 1.1);
                    ctx.lineTo(-r * 0.2, -r * 0.75);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.35, -r * 0.7);
                    ctx.lineTo(r * 0.5, -r * 1.1);
                    ctx.lineTo(r * 0.2, -r * 0.75);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#ff0';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#f80';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.18, -r * 0.55, r * 0.12, r * 0.08, -0.2, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.18, -r * 0.55, r * 0.12, r * 0.08, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.18, -r * 0.55, r * 0.04, r * 0.06, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.18, -r * 0.55, r * 0.04, r * 0.06, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Snout
                    ctx.fillStyle = isStunned ? '#99e' : '#7a0000';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.3, r * 0.25, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Nostrils with smoke
                    ctx.fillStyle = '#f80';
                    ctx.beginPath();
                    ctx.arc(-r * 0.1, -r * 0.28, r * 0.05, 0, Math.PI * 2);
                    ctx.arc(r * 0.1, -r * 0.28, r * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    // Spines
                    ctx.fillStyle = '#440000';
                    for (let i = 0; i < 5; i++) {
                        const spineY = -r * 0.7 + i * r * 0.35;
                        const spineSize = r * 0.15 - i * r * 0.02;
                        ctx.beginPath();
                        ctx.moveTo(0, spineY);
                        ctx.lineTo(-spineSize, spineY + spineSize);
                        ctx.lineTo(spineSize, spineY + spineSize);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;

                case 'beholder':
                    // Main eye body
                    ctx.fillStyle = isStunned ? '#aaf' : '#8b4513';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyestalks (4 on top)
                    ctx.strokeStyle = isStunned ? '#99e' : '#6b3503';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 4; i++) {
                        const stalkAngle = -Math.PI * 0.8 + (i * Math.PI * 0.4);
                        const wobble = Math.sin(Date.now() / 150 + i) * 0.1;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(stalkAngle) * r * 0.5, Math.sin(stalkAngle) * r * 0.5);
                        ctx.quadraticCurveTo(
                            Math.cos(stalkAngle + wobble) * r * 0.8,
                            Math.sin(stalkAngle + wobble) * r * 0.8 - r * 0.2,
                            Math.cos(stalkAngle) * r * 1.1,
                            Math.sin(stalkAngle) * r * 1.1
                        );
                        ctx.stroke();
                        // Mini eye at end
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(Math.cos(stalkAngle) * r * 1.1, Math.sin(stalkAngle) * r * 1.1, r * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(Math.cos(stalkAngle) * r * 1.1, Math.sin(stalkAngle) * r * 1.1, r * 0.05, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Central eye
                    ctx.fillStyle = '#fffff0';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#8b0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye glow
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#f00';
                    ctx.fillStyle = '#f44';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Mouth with teeth
                    ctx.fillStyle = '#3a1a03';
                    ctx.beginPath();
                    ctx.arc(0, r * 0.4, r * 0.35, 0.2, Math.PI - 0.2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    for (let i = -3; i <= 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * r * 0.08, r * 0.35);
                        ctx.lineTo(i * r * 0.08 - r * 0.03, r * 0.55);
                        ctx.lineTo(i * r * 0.08 + r * 0.03, r * 0.55);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;

                case 'golem':
                    // Rocky body
                    ctx.fillStyle = isStunned ? '#aaf' : '#696969';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.7, -r * 0.8);
                    ctx.lineTo(-r * 0.9, 0);
                    ctx.lineTo(-r * 0.7, r * 0.9);
                    ctx.lineTo(r * 0.7, r * 0.9);
                    ctx.lineTo(r * 0.9, 0);
                    ctx.lineTo(r * 0.7, -r * 0.8);
                    ctx.closePath();
                    ctx.fill();
                    // Cracks/texture
                    ctx.strokeStyle = isStunned ? '#88c' : '#4a4a4a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.4, -r * 0.6);
                    ctx.lineTo(-r * 0.2, r * 0.2);
                    ctx.lineTo(-r * 0.5, r * 0.7);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, -r * 0.5);
                    ctx.lineTo(r * 0.1, 0);
                    ctx.lineTo(r * 0.4, r * 0.5);
                    ctx.stroke();
                    // Glowing runes
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#0af';
                    ctx.strokeStyle = '#0af';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.2, -r * 0.1);
                    ctx.lineTo(r * 0.2, -r * 0.1);
                    ctx.moveTo(0, -r * 0.25);
                    ctx.lineTo(0, r * 0.15);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    // Eyes (glowing blue)
                    ctx.fillStyle = '#0af';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0af';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.4, r * 0.12, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.4, r * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;

                case 'banshee':
                    // Ethereal glow
                    const bansheeGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                    bansheeGrad.addColorStop(0, isStunned ? 'rgba(150,150,255,0.9)' : 'rgba(200,200,255,0.9)');
                    bansheeGrad.addColorStop(0.5, isStunned ? 'rgba(100,100,200,0.5)' : 'rgba(150,150,200,0.5)');
                    bansheeGrad.addColorStop(1, 'rgba(100,100,150,0)');
                    ctx.fillStyle = bansheeGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Flowing form
                    ctx.fillStyle = isStunned ? 'rgba(150,150,255,0.7)' : 'rgba(220,220,255,0.7)';
                    ctx.beginPath();
                    ctx.moveTo(0, -r * 0.8);
                    ctx.quadraticCurveTo(-r * 0.5, -r * 0.4, -r * 0.6, r * 0.2);
                    ctx.quadraticCurveTo(-r * 0.4, r * 0.8, 0, r);
                    ctx.quadraticCurveTo(r * 0.4, r * 0.8, r * 0.6, r * 0.2);
                    ctx.quadraticCurveTo(r * 0.5, -r * 0.4, 0, -r * 0.8);
                    ctx.fill();
                    // Face
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    // Empty eye sockets
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.12, -r * 0.35, r * 0.1, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.12, -r * 0.35, r * 0.1, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Screaming mouth
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.05, r * 0.15, r * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Flowing hair
                    ctx.strokeStyle = isStunned ? 'rgba(150,150,255,0.6)' : 'rgba(200,200,255,0.6)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 5; i++) {
                        const hairWave = Math.sin(Date.now() / 100 + i) * r * 0.1;
                        ctx.beginPath();
                        ctx.moveTo(-r * 0.3 + i * r * 0.15, -r * 0.5);
                        ctx.quadraticCurveTo(-r * 0.3 + i * r * 0.15 + hairWave, -r * 0.9, -r * 0.4 + i * r * 0.2, -r * 1.1);
                        ctx.stroke();
                    }
                    break;

                case 'werewolf':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#4a4a4a';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.1, r * 0.7, r * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Fur texture
                    ctx.strokeStyle = isStunned ? '#88c' : '#3a3a3a';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 12; i++) {
                        const fAngle = (i / 12) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(fAngle) * r * 0.5, Math.sin(fAngle) * r * 0.5 + r * 0.1);
                        ctx.lineTo(Math.cos(fAngle) * r * 0.75, Math.sin(fAngle) * r * 0.85 + r * 0.1);
                        ctx.stroke();
                    }
                    // Snout
                    ctx.fillStyle = isStunned ? '#99e' : '#5a5a5a';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.1, r * 0.4, r * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = isStunned ? '#aaf' : '#2a2a2a';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.05, r * 0.25, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.15, r * 0.12, r * 0.08, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes (yellow, feral)
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.2, -r * 0.35, r * 0.12, r * 0.08, -0.2, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.2, -r * 0.35, r * 0.12, r * 0.08, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.2, -r * 0.35, r * 0.04, 0, Math.PI * 2);
                    ctx.arc(r * 0.2, -r * 0.35, r * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    // Ears
                    ctx.fillStyle = isStunned ? '#aaf' : '#4a4a4a';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.4, -r * 0.5);
                    ctx.lineTo(-r * 0.55, -r * 0.95);
                    ctx.lineTo(-r * 0.2, -r * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.4, -r * 0.5);
                    ctx.lineTo(r * 0.55, -r * 0.95);
                    ctx.lineTo(r * 0.2, -r * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    // Fangs
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.15, r * 0.05);
                    ctx.lineTo(-r * 0.1, r * 0.25);
                    ctx.lineTo(-r * 0.05, r * 0.05);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.05, r * 0.05);
                    ctx.lineTo(r * 0.1, r * 0.25);
                    ctx.lineTo(r * 0.15, r * 0.05);
                    ctx.fill();
                    break;

                case 'demon':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#8b0000';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r * 0.7, r * 0.85, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Wings
                    ctx.fillStyle = isStunned ? '#88a' : '#4a0000';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.5, -r * 0.2);
                    ctx.quadraticCurveTo(-r * 1.2, -r * 0.6, -r * 1.1, r * 0.1);
                    ctx.quadraticCurveTo(-r * 0.9, r * 0.3, -r * 0.5, r * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.5, -r * 0.2);
                    ctx.quadraticCurveTo(r * 1.2, -r * 0.6, r * 1.1, r * 0.1);
                    ctx.quadraticCurveTo(r * 0.9, r * 0.3, r * 0.5, r * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // Horns
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.3, -r * 0.6);
                    ctx.quadraticCurveTo(-r * 0.5, -r * 1.1, -r * 0.2, -r * 1.0);
                    ctx.lineTo(-r * 0.15, -r * 0.65);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, -r * 0.6);
                    ctx.quadraticCurveTo(r * 0.5, -r * 1.1, r * 0.2, -r * 1.0);
                    ctx.lineTo(r * 0.15, -r * 0.65);
                    ctx.closePath();
                    ctx.fill();
                    // Face
                    ctx.fillStyle = isStunned ? '#99e' : '#6b0000';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.25, r * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Glowing eyes
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#f80';
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.15, -r * 0.3, r * 0.1, r * 0.06, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.15, -r * 0.3, r * 0.1, r * 0.06, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Evil grin
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.15, r * 0.2, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                    // Tail
                    ctx.strokeStyle = isStunned ? '#aaf' : '#8b0000';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, r * 0.7);
                    ctx.quadraticCurveTo(r * 0.5, r * 1.0, r * 0.3, r * 1.2);
                    ctx.stroke();
                    // Tail point
                    ctx.fillStyle = isStunned ? '#aaf' : '#8b0000';
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, r * 1.15);
                    ctx.lineTo(r * 0.5, r * 1.3);
                    ctx.lineTo(r * 0.2, r * 1.25);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case 'fireElemental':
                    // Flame body with animation
                    const fireTime = Date.now() / 100;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#f80';
                    // Outer flames
                    ctx.fillStyle = isStunned ? 'rgba(150,150,255,0.6)' : 'rgba(255,100,0,0.6)';
                    for (let i = 0; i < 8; i++) {
                        const flameAngle = (i / 8) * Math.PI * 2;
                        const flameHeight = r * (0.8 + Math.sin(fireTime + i) * 0.3);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.quadraticCurveTo(
                            Math.cos(flameAngle) * r * 0.5,
                            Math.sin(flameAngle) * r * 0.5,
                            Math.cos(flameAngle) * flameHeight,
                            Math.sin(flameAngle) * flameHeight
                        );
                        ctx.quadraticCurveTo(
                            Math.cos(flameAngle + 0.2) * r * 0.3,
                            Math.sin(flameAngle + 0.2) * r * 0.3,
                            0, 0
                        );
                        ctx.fill();
                    }
                    // Core body
                    ctx.fillStyle = isStunned ? 'rgba(150,150,255,0.8)' : 'rgba(255,200,50,0.9)';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Inner core
                    ctx.fillStyle = isStunned ? '#aaf' : '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.12, -r * 0.1, r * 0.08, r * 0.12, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.12, -r * 0.1, r * 0.08, r * 0.12, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;

                case 'troll':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#556b2f';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.1, r * 0.8, r * 0.9, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Warty texture
                    ctx.fillStyle = isStunned ? '#99e' : '#445a1f';
                    for (let i = 0; i < 6; i++) {
                        const wx = (Math.random() - 0.5) * r * 1.2;
                        const wy = (Math.random() - 0.5) * r * 1.4;
                        ctx.beginPath();
                        ctx.arc(wx, wy, r * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Head
                    ctx.fillStyle = isStunned ? '#aaf' : '#556b2f';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.4, r * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Big nose
                    ctx.fillStyle = isStunned ? '#99e' : '#445a1f';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.2, r * 0.25, r * 0.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Small angry eyes
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(-r * 0.2, -r * 0.5, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.2, -r * 0.5, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.2, -r * 0.5, r * 0.04, 0, Math.PI * 2);
                    ctx.arc(r * 0.2, -r * 0.5, r * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    // Underbite with tusks
                    ctx.fillStyle = isStunned ? '#99e' : '#445a1f';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.1, r * 0.3, 0, Math.PI);
                    ctx.fill();
                    ctx.fillStyle = '#fffff0';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.2, -r * 0.1);
                    ctx.lineTo(-r * 0.25, -r * 0.35);
                    ctx.lineTo(-r * 0.1, -r * 0.1);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.2, -r * 0.1);
                    ctx.lineTo(r * 0.25, -r * 0.35);
                    ctx.lineTo(r * 0.1, -r * 0.1);
                    ctx.fill();
                    // Regen effect (green glow)
                    if (e.special === 'regen') {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#0f0';
                        ctx.strokeStyle = 'rgba(0,255,0,0.5)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, r * 0.9, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                    break;

                case 'medusa':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#228b22';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.2, r * 0.5, r * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Snake tail
                    ctx.strokeStyle = isStunned ? '#aaf' : '#228b22';
                    ctx.lineWidth = r * 0.3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, r * 0.6);
                    ctx.quadraticCurveTo(r * 0.4, r * 1.0, 0, r * 1.2);
                    ctx.stroke();
                    // Face
                    ctx.fillStyle = '#9acd32';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.2, r * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Snake hair
                    ctx.strokeStyle = isStunned ? '#99e' : '#228b22';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 8; i++) {
                        const snakeAngle = -Math.PI * 0.8 + (i * Math.PI * 0.2);
                        const snakeWave = Math.sin(Date.now() / 120 + i * 0.5) * r * 0.15;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(snakeAngle) * r * 0.3, -r * 0.3 + Math.sin(snakeAngle) * r * 0.2);
                        ctx.quadraticCurveTo(
                            Math.cos(snakeAngle) * r * 0.6 + snakeWave,
                            -r * 0.5 + Math.sin(snakeAngle) * r * 0.3,
                            Math.cos(snakeAngle) * r * 0.8,
                            -r * 0.7 + Math.sin(snakeAngle) * r * 0.4
                        );
                        ctx.stroke();
                        // Snake heads
                        ctx.fillStyle = isStunned ? '#99e' : '#1a6b1a';
                        ctx.beginPath();
                        ctx.arc(Math.cos(snakeAngle) * r * 0.8, -r * 0.7 + Math.sin(snakeAngle) * r * 0.4, r * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Eyes (glowing for petrify)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0';
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(-r * 0.15, -r * 0.25, r * 0.1, 0, Math.PI * 2);
                    ctx.arc(r * 0.15, -r * 0.25, r * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.15, -r * 0.25, r * 0.03, r * 0.07, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.15, -r * 0.25, r * 0.03, r * 0.07, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'griffin':
                    // Lion body
                    ctx.fillStyle = isStunned ? '#aaf' : '#daa520';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.2, r * 0.7, r * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Wings
                    ctx.fillStyle = isStunned ? '#99e' : '#8b6914';
                    const gWingFlap = Math.sin(Date.now() / 80) * 0.25;
                    ctx.save();
                    ctx.rotate(-0.5 + gWingFlap);
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.4, 0);
                    ctx.quadraticCurveTo(-r * 1.0, -r * 0.4, -r * 1.2, r * 0.1);
                    ctx.quadraticCurveTo(-r * 0.8, r * 0.2, -r * 0.4, 0);
                    ctx.fill();
                    // Feather details
                    ctx.strokeStyle = isStunned ? '#aaf' : '#c9a020';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.6, -r * 0.1);
                    ctx.lineTo(-r * 1.0, r * 0.05);
                    ctx.moveTo(-r * 0.7, 0);
                    ctx.lineTo(-r * 1.1, r * 0.1);
                    ctx.stroke();
                    ctx.restore();
                    ctx.save();
                    ctx.rotate(0.5 - gWingFlap);
                    ctx.beginPath();
                    ctx.moveTo(r * 0.4, 0);
                    ctx.quadraticCurveTo(r * 1.0, -r * 0.4, r * 1.2, r * 0.1);
                    ctx.quadraticCurveTo(r * 0.8, r * 0.2, r * 0.4, 0);
                    ctx.fill();
                    ctx.strokeStyle = isStunned ? '#aaf' : '#c9a020';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(r * 0.6, -r * 0.1);
                    ctx.lineTo(r * 1.0, r * 0.05);
                    ctx.moveTo(r * 0.7, 0);
                    ctx.lineTo(r * 1.1, r * 0.1);
                    ctx.stroke();
                    ctx.restore();
                    // Eagle head
                    ctx.fillStyle = isStunned ? '#aaf' : '#f5deb3';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.35, r * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Beak
                    ctx.fillStyle = '#f4a460';
                    ctx.beginPath();
                    ctx.moveTo(0, -r * 0.3);
                    ctx.lineTo(r * 0.15, -r * 0.15);
                    ctx.lineTo(0, r * 0.0);
                    ctx.lineTo(-r * 0.15, -r * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.15, -r * 0.4, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.15, -r * 0.4, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(-r * 0.15, -r * 0.4, r * 0.04, 0, Math.PI * 2);
                    ctx.arc(r * 0.15, -r * 0.4, r * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    // Tail tuft
                    ctx.fillStyle = isStunned ? '#aaf' : '#daa520';
                    ctx.beginPath();
                    ctx.moveTo(0, r * 0.7);
                    ctx.quadraticCurveTo(-r * 0.2, r * 1.0, -r * 0.1, r * 1.1);
                    ctx.quadraticCurveTo(0, r * 0.9, r * 0.1, r * 1.1);
                    ctx.quadraticCurveTo(r * 0.2, r * 1.0, 0, r * 0.7);
                    ctx.fill();
                    break;

                case 'necromancer':
                    // Dark robe
                    ctx.fillStyle = isStunned ? '#66a' : '#1a0a2a';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.4, -r * 0.4);
                    ctx.lineTo(-r * 0.7, r);
                    ctx.lineTo(r * 0.7, r);
                    ctx.lineTo(r * 0.4, -r * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    // Hood
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.5, Math.PI, 0);
                    ctx.lineTo(r * 0.4, -r * 0.1);
                    ctx.quadraticCurveTo(0, r * 0.1, -r * 0.4, -r * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // Shadow face
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.2, r * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Glowing eyes
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#a0f';
                    ctx.fillStyle = '#a0f';
                    ctx.beginPath();
                    ctx.arc(-r * 0.12, -r * 0.25, r * 0.06, 0, Math.PI * 2);
                    ctx.arc(r * 0.12, -r * 0.25, r * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Staff
                    ctx.strokeStyle = '#3a2a1a';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(r * 0.5, -r * 0.5);
                    ctx.lineTo(r * 0.5, r * 0.9);
                    ctx.stroke();
                    // Skull on staff
                    ctx.fillStyle = '#ddd';
                    ctx.beginPath();
                    ctx.arc(r * 0.5, -r * 0.6, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(r * 0.45, -r * 0.62, r * 0.04, 0, Math.PI * 2);
                    ctx.arc(r * 0.55, -r * 0.62, r * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    // Dark magic aura
                    ctx.strokeStyle = 'rgba(160,0,255,0.4)';
                    ctx.lineWidth = 2;
                    const auraPhase = Date.now() / 200;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(0, 0, r * (0.7 + i * 0.15 + Math.sin(auraPhase + i) * 0.1), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    // Floating runes
                    ctx.fillStyle = 'rgba(160,0,255,0.6)';
                    ctx.font = `${r * 0.2}px serif`;
                    const runes = ['', '', ''];
                    for (let i = 0; i < 3; i++) {
                        const runeAngle = auraPhase + (i * Math.PI * 2 / 3);
                        const runeX = Math.cos(runeAngle) * r * 0.8;
                        const runeY = Math.sin(runeAngle) * r * 0.8;
                        ctx.fillText(runes[i], runeX - r * 0.05, runeY + r * 0.05);
                    }
                    break;

                default:
                    // Fallback circle
                    ctx.fillStyle = isStunned ? '#aaf' : e.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
            }

            ctx.restore();

            // Health bar (drawn in world space)
            ctx.save();
            const barWidth = e.radius * 2;
            const barHeight = 4;
            ctx.fillStyle = '#333';
            ctx.fillRect(e.x - barWidth/2, e.y - e.radius - 15, barWidth, barHeight);
            ctx.fillStyle = e.health > e.maxHealth * 0.3 ? '#4a4' : '#a44';
            ctx.fillRect(e.x - barWidth/2, e.y - e.radius - 15, barWidth * (e.health / e.maxHealth), barHeight);
            ctx.restore();
        }

        function drawBullet(b) {
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(b.angle || 0);

            const color = classDefinitions[player.class]?.color || '#ffd700';

            switch(b.type) {
                case 'magic':
                    ctx.fillStyle = b.isCrit ? '#ffff00' : '#00ffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = b.isCrit ? '#ffff00' : '#00ffff';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;

                case 'axe':
                    ctx.fillStyle = b.isCrit ? '#ffff00' : '#8b4513';
                    ctx.beginPath();
                    ctx.moveTo(b.radius, 0);
                    ctx.lineTo(0, -b.radius);
                    ctx.lineTo(-b.radius * 0.5, 0);
                    ctx.lineTo(0, b.radius);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#666';
                    ctx.fillRect(-b.radius * 0.3, -2, b.radius, 4);
                    break;

                case 'shuriken':
                    ctx.fillStyle = b.isCrit ? '#ffff00' : '#c0c0c0';
                    for (let i = 0; i < 4; i++) {
                        ctx.save();
                        ctx.rotate((Math.PI / 2) * i);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(b.radius, -b.radius * 0.3);
                        ctx.lineTo(b.radius * 0.3, 0);
                        ctx.lineTo(b.radius, b.radius * 0.3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    break;

                case 'sword':
                    ctx.fillStyle = b.isCrit ? '#ffff00' : '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(b.radius, 0);
                    ctx.lineTo(-b.radius * 0.5, -b.radius * 0.4);
                    ctx.lineTo(-b.radius * 0.5, b.radius * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(-b.radius * 0.8, -b.radius * 0.2, b.radius * 0.4, b.radius * 0.4);
                    break;

                default:
                    ctx.fillStyle = b.isCrit ? '#ffff00' : '#ffd700';
                    ctx.beginPath();
                    ctx.arc(0, 0, b.radius, 0, Math.PI * 2);
                    ctx.fill();
            }

            ctx.restore();
        }

        function draw() {
            // Background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);

            // Grid
            ctx.strokeStyle = '#2a2a4e';
            ctx.lineWidth = 1;
            for (let x = 0; x < W; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, H);
                ctx.stroke();
            }
            for (let y = 0; y < H; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }

            // Particles
            for (const p of particles) {
                ctx.globalAlpha = p.life / 40;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Bullets
            for (const b of bullets) {
                drawBullet(b);
            }

            // Enemies
            for (const e of enemies) {
                drawEnemy(e);
            }

            // Player
            if (gameState === 'playing') {
                drawPlayer();
            }

            // Health bar
            const hbW = 200, hbH = 20;
            ctx.fillStyle = '#333';
            ctx.fillRect(W - hbW - 20, 20, hbW, hbH);

            // Rage indicator for barbarian
            let healthColor = player.health > player.maxHealth * 0.3 ? '#4a4' : '#a44';
            if (player.class === 'barbarian' && player.rageDamage && player.health < player.maxHealth * 0.5) {
                healthColor = '#ff4400';
            }
            ctx.fillStyle = healthColor;
            ctx.fillRect(W - hbW - 20, 20, hbW * (player.health / player.maxHealth), hbH);
            ctx.strokeStyle = classDefinitions[player.class]?.color || '#c9a227';
            ctx.lineWidth = 2;
            ctx.strokeRect(W - hbW - 20, 20, hbW, hbH);
            ctx.fillStyle = '#fff';
            ctx.font = '14px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.ceil(player.health)} / ${player.maxHealth}`, W - hbW/2 - 20, 35);

            // Ability cooldown bar
            if (player.class && classDefinitions[player.class]) {
                const classDef = classDefinitions[player.class];
                const now = Date.now();
                const cooldownTotal = classDef.abilityCooldown * player.abilityCooldownMult;
                const cooldownRemaining = Math.max(0, player.abilityCooldownEnd - now);
                const cooldownProgress = 1 - (cooldownRemaining / cooldownTotal);

                const abW = 200, abH = 16;
                const abY = 48;

                // Background
                ctx.fillStyle = '#333';
                ctx.fillRect(W - abW - 20, abY, abW, abH);

                // Cooldown fill
                if (cooldownProgress >= 1) {
                    ctx.fillStyle = classDef.color;
                } else {
                    ctx.fillStyle = '#666';
                }
                ctx.fillRect(W - abW - 20, abY, abW * Math.min(1, cooldownProgress), abH);

                // Active ability indicator
                if (player.rageActive || player.shieldActive) {
                    const activeProgress = (player.abilityActiveEnd - now) / (classDef.abilityDuration * player.abilityDurationMult);
                    ctx.fillStyle = player.rageActive ? '#ff4400' : '#ffd700';
                    ctx.fillRect(W - abW - 20, abY, abW * Math.max(0, activeProgress), abH);
                }

                // Border
                ctx.strokeStyle = classDef.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(W - abW - 20, abY, abW, abH);

                // Ability name and key
                ctx.fillStyle = '#fff';
                ctx.font = '12px Georgia';
                ctx.textAlign = 'center';
                const abilityText = cooldownProgress >= 1 ? `[SPACE] ${classDef.abilityName}` : `${classDef.abilityName} (${(cooldownRemaining / 1000).toFixed(1)}s)`;
                ctx.fillText(abilityText, W - abW/2 - 20, abY + 12);
            }

            // Draw active ability effects around player
            if (gameState === 'playing') {
                const now = Date.now();

                // Battle Rage effect - red pulsing aura
                if (player.rageActive) {
                    const pulse = 0.5 + Math.sin(now / 100) * 0.2;
                    ctx.strokeStyle = `rgba(255, 68, 0, ${pulse})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 10 + Math.sin(now / 80) * 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = `rgba(255, 100, 0, ${pulse * 0.5})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 18 + Math.sin(now / 120) * 4, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Shield Wall effect - golden rotating shield
                if (player.shieldActive) {
                    ctx.save();
                    ctx.translate(player.x, player.y);
                    ctx.rotate(now / 500);
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, player.radius + 15, angle, angle + 0.5);
                        ctx.stroke();
                    }
                    ctx.restore();
                    // Inner glow
                    const gradient = ctx.createRadialGradient(player.x, player.y, player.radius, player.x, player.y, player.radius + 25);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 25, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Arcane Nova expanding ring effect
                if (player.novaEffect && now - player.novaEffect.time < 500) {
                    const progress = (now - player.novaEffect.time) / 500;
                    const radius = player.novaEffect.radius * progress;
                    ctx.strokeStyle = `rgba(0, 255, 255, ${1 - progress})`;
                    ctx.lineWidth = 4 * (1 - progress);
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = `rgba(147, 112, 219, ${(1 - progress) * 0.5})`;
                    ctx.lineWidth = 8 * (1 - progress);
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, radius * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Update UI
            document.getElementById('health').textContent = `Health: ${Math.ceil(player.health)}`;
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('souls').textContent = `Souls: ${souls}`;
            document.getElementById('wave').textContent = `Wave: ${wave}`;
            document.getElementById('enemies').textContent = `Enemies: ${enemiesRemaining}`;
        }

        function gameLoop() {
            if (gameState === 'playing') {
                updatePlayer();
                updateAbilities();
                updateBullets();
                updateEnemies();
                updateParticles();

                if (enemiesRemaining <= 0 && enemies.length === 0) {
                    wave++;
                    gameState = 'upgrading';
                    playSound('waveComplete');
                    showUpgradeMenu();
                }
            }

            draw();
            requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>
