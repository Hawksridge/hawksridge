<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mythic Slayer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Georgia', serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
        }
        #gameCanvas {
            border: 4px solid #c9a227;
            border-radius: 8px;
            cursor: crosshair;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #f0e68c;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        #upgradeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.95);
            border: 3px solid #c9a227;
            border-radius: 15px;
            padding: 30px;
            display: none;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #upgradeMenu h2 {
            color: #c9a227;
            text-align: center;
            margin-bottom: 20px;
            font-size: 28px;
        }
        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .upgrade-btn {
            background: linear-gradient(145deg, #2a2a4e, #1a1a2e);
            border: 2px solid #c9a227;
            color: #f0e68c;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Georgia', serif;
        }
        .upgrade-btn:hover {
            background: linear-gradient(145deg, #3a3a6e, #2a2a4e);
            transform: scale(1.05);
        }
        .upgrade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .upgrade-btn .name { font-weight: bold; font-size: 16px; }
        .upgrade-btn .desc { font-size: 12px; color: #aaa; margin: 5px 0; }
        .upgrade-btn .cost { color: #ffd700; font-size: 14px; }
        .upgrade-btn .level { color: #88ff88; font-size: 12px; }
        #startWaveBtn {
            display: block;
            margin: 0 auto;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(145deg, #4a7c3f, #2e5a24);
            border: 2px solid #7cb342;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Georgia', serif;
        }
        #startWaveBtn:hover {
            background: linear-gradient(145deg, #5a9c4f, #3e7a34);
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f0e68c;
        }
        #startScreen h1 {
            font-size: 48px;
            color: #c9a227;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            margin-bottom: 10px;
        }
        #startScreen .subtitle {
            font-size: 18px;
            margin-bottom: 30px;
            color: #aaa;
        }
        .class-select {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        .class-btn {
            padding: 20px;
            font-size: 18px;
            background: linear-gradient(145deg, #2a2a4e, #1a1a2e);
            border: 3px solid #555;
            color: #f0e68c;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            transition: all 0.3s;
        }
        .class-btn:hover {
            transform: scale(1.05);
        }
        .class-btn.selected {
            border-color: #c9a227;
            box-shadow: 0 0 20px rgba(201, 162, 39, 0.5);
        }
        .class-btn .class-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .class-btn .class-desc {
            font-size: 12px;
            color: #aaa;
        }
        .class-btn.mage { border-color: #6a5acd; }
        .class-btn.mage.selected { border-color: #9370db; box-shadow: 0 0 20px rgba(147, 112, 219, 0.5); }
        .class-btn.barbarian { border-color: #8b0000; }
        .class-btn.barbarian.selected { border-color: #dc143c; box-shadow: 0 0 20px rgba(220, 20, 60, 0.5); }
        .class-btn.ninja { border-color: #2f4f4f; }
        .class-btn.ninja.selected { border-color: #5f9f9f; box-shadow: 0 0 20px rgba(95, 159, 159, 0.5); }
        .class-btn.knight { border-color: #b8860b; }
        .class-btn.knight.selected { border-color: #ffd700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
        #startBtn {
            padding: 20px 50px;
            font-size: 24px;
            background: linear-gradient(145deg, #8b0000, #5a0000);
            border: 3px solid #c9a227;
            color: #f0e68c;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            opacity: 0.5;
            pointer-events: none;
        }
        #startBtn.enabled {
            opacity: 1;
            pointer-events: auto;
        }
        #startBtn.enabled:hover {
            background: linear-gradient(145deg, #ab2020, #7a1010);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f0e68c;
            display: none;
        }
        #gameOver h1 { font-size: 48px; color: #8b0000; margin-bottom: 20px; }
        .controls {
            font-size: 14px;
            color: #888;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        <div id="ui">
            <div id="health">Health: 100</div>
            <div id="score">Score: 0</div>
            <div id="souls">Souls: 0</div>
            <div id="wave">Wave: 1</div>
            <div id="enemies">Enemies: 0</div>
            <div id="classDisplay">Class: -</div>
        </div>
        <div id="startScreen">
            <h1>MYTHIC SLAYER</h1>
            <p class="subtitle">Slay legendary creatures from myth and legend</p>
            <p style="color:#c9a227;margin-bottom:15px;">Choose Your Class:</p>
            <div class="class-select">
                <button class="class-btn mage" data-class="mage">
                    <div class="class-name">MAGE</div>
                    <div class="class-desc">Arcane projectiles, high damage, fragile<br>Special: Piercing magic bolts</div>
                </button>
                <button class="class-btn barbarian" data-class="barbarian">
                    <div class="class-name">BARBARIAN</div>
                    <div class="class-desc">Throwing axes, tanky, rage mode<br>Special: Attacks grow stronger when hurt</div>
                </button>
                <button class="class-btn ninja" data-class="ninja">
                    <div class="class-name">NINJA</div>
                    <div class="class-desc">Shurikens, fast, critical hits<br>Special: High speed & crit chance</div>
                </button>
                <button class="class-btn knight" data-class="knight">
                    <div class="class-name">KNIGHT</div>
                    <div class="class-desc">Balanced, durable, steady damage<br>Special: Damage reduction & life regen</div>
                </button>
            </div>
            <button id="startBtn">BEGIN THE HUNT</button>
            <div class="controls">
                <p>WASD or Arrow Keys to move | Mouse to aim | Hold Left Click to fire</p>
            </div>
        </div>
        <div id="upgradeMenu">
            <h2>UPGRADE YOUR ARSENAL</h2>
            <div id="soulsDisplay" style="text-align:center;color:#ffd700;font-size:20px;margin-bottom:15px;">Souls: 0</div>
            <button id="startWaveBtn">START</button>
            <div class="upgrade-grid" id="upgradeGrid"></div>
        </div>
        <div id="gameOver">
            <h1>FALLEN IN BATTLE</h1>
            <p id="finalScore">Final Score: 0</p>
            <p id="finalWave">Reached Wave: 1</p>
            <button id="restartBtn" style="margin-top:20px;padding:15px 30px;font-size:18px;background:#8b0000;border:2px solid #c9a227;color:#f0e68c;border-radius:8px;cursor:pointer;">TRY AGAIN</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;  // Screen width
        const H = canvas.height; // Screen height

        // ===== WORLD/CAMERA SYSTEM =====
        const WORLD_WIDTH = 4000;  // 4000px wide world
        const WORLD_HEIGHT = 4000; // 4000px tall world
        const SPAWN_PROTECTION_RADIUS = 300;
        const ENEMY_SPAWN_DISTANCE = 600; // Spawn enemies off-screen

        // Camera position (top-left corner of viewport in world coords)
        let camera = { x: 0, y: 0 };

        function updateCamera() {
            // Center camera on player with smooth follow
            const targetX = player.x - W / 2;
            const targetY = player.y - H / 2;
            camera.x += (targetX - camera.x) * 0.1;
            camera.y += (targetY - camera.y) * 0.1;
            // Clamp to world bounds
            camera.x = Math.max(0, Math.min(WORLD_WIDTH - W, camera.x));
            camera.y = Math.max(0, Math.min(WORLD_HEIGHT - H, camera.y));
        }

        function worldToScreen(wx, wy) {
            return { x: wx - camera.x, y: wy - camera.y };
        }

        function screenToWorld(sx, sy) {
            return { x: sx + camera.x, y: sy + camera.y };
        }

        function isOnScreen(wx, wy, margin = 100) {
            return wx > camera.x - margin && wx < camera.x + W + margin &&
                   wy > camera.y - margin && wy < camera.y + H + margin;
        }

        // ===== MAP GENERATION - FANTASY FOREST =====
        let mapProps = [];      // Decorative props (trees, bushes, flowers, etc.)
        let hazards = [];       // Environmental hazards
        let treasureChests = []; // Loot chests

        function generateMap() {
            mapProps = [];
            hazards = [];
            treasureChests = [];

            // Generate forest floor pattern (stored for rendering)
            // Generate trees (large props that block nothing but look nice)
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * WORLD_WIDTH;
                const y = Math.random() * WORLD_HEIGHT;
                const type = Math.random() < 0.7 ? 'tree' : (Math.random() < 0.5 ? 'pine' : 'willow');
                const scale = 0.7 + Math.random() * 0.6;
                mapProps.push({ x, y, type, scale, z: y }); // z for sorting
            }

            // Bushes
            for (let i = 0; i < 150; i++) {
                mapProps.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    type: 'bush',
                    scale: 0.5 + Math.random() * 0.5,
                    variant: Math.floor(Math.random() * 3)
                });
            }

            // Flowers and mushrooms
            for (let i = 0; i < 300; i++) {
                mapProps.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    type: Math.random() < 0.6 ? 'flowers' : 'mushroom',
                    scale: 0.3 + Math.random() * 0.4,
                    color: ['#ff69b4', '#ff6347', '#ffd700', '#87ceeb', '#da70d6'][Math.floor(Math.random() * 5)]
                });
            }

            // Rocks
            for (let i = 0; i < 80; i++) {
                mapProps.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    type: 'rock',
                    scale: 0.4 + Math.random() * 0.8
                });
            }

            // Glowing crystals (magical forest element)
            for (let i = 0; i < 40; i++) {
                mapProps.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    type: 'crystal',
                    scale: 0.5 + Math.random() * 0.5,
                    color: ['#00ffff', '#ff00ff', '#00ff00', '#ffff00'][Math.floor(Math.random() * 4)]
                });
            }

            // Sort props by Y for proper layering
            mapProps.sort((a, b) => (a.z || a.y) - (b.z || b.y));

            // ===== HAZARDS =====
            // Thorn patches - damage on contact
            for (let i = 0; i < 25; i++) {
                hazards.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    type: 'thorns',
                    radius: 40 + Math.random() * 30,
                    damage: 5,
                    health: 150,
                    maxHealth: 150
                });
            }

            // Poison spore plants - AoE damage over time
            for (let i = 0; i < 15; i++) {
                hazards.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    type: 'spore',
                    radius: 30,
                    damageRadius: 80,
                    damage: 2,
                    health: 200,
                    maxHealth: 200,
                    pulseTimer: 0
                });
            }

            // Fire geysers - periodic fire bursts
            for (let i = 0; i < 12; i++) {
                hazards.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    type: 'geyser',
                    radius: 25,
                    damageRadius: 100,
                    damage: 20,
                    health: 300,
                    maxHealth: 300,
                    cooldown: 3000 + Math.random() * 2000,
                    lastFire: 0,
                    firing: false
                });
            }

            // Arcane turrets - shoot projectiles at player
            for (let i = 0; i < 8; i++) {
                hazards.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    type: 'turret',
                    radius: 25,
                    damage: 15,
                    health: 400,
                    maxHealth: 400,
                    range: 350,
                    fireRate: 2000,
                    lastShot: 0
                });
            }
        }

        // Hazard projectiles
        let hazardProjectiles = [];

        function updateHazards() {
            const now = Date.now();

            for (let i = hazards.length - 1; i >= 0; i--) {
                const h = hazards[i];
                if (h.health <= 0) {
                    // Destruction effect
                    for (let p = 0; p < 10; p++) {
                        particles.push({
                            x: h.x, y: h.y,
                            vx: (Math.random() - 0.5) * 6,
                            vy: (Math.random() - 0.5) * 6,
                            life: 30,
                            color: h.type === 'geyser' ? '#ff4400' : '#44aa44',
                            radius: 5
                        });
                    }
                    hazards.splice(i, 1);
                    continue;
                }

                const dist = Math.hypot(player.x - h.x, player.y - h.y);

                switch(h.type) {
                    case 'thorns':
                        if (dist < h.radius + player.radius && player.invincible < now) {
                            player.health -= h.damage * (1 - player.damageReduction);
                            player.invincible = now + 200;
                        }
                        break;

                    case 'spore':
                        h.pulseTimer = (h.pulseTimer || 0) + 1;
                        if (dist < h.damageRadius && player.invincible < now) {
                            player.health -= h.damage * (1 - player.damageReduction) * 0.05;
                            // Poison particles
                            if (Math.random() < 0.1) {
                                particles.push({
                                    x: player.x + (Math.random() - 0.5) * 20,
                                    y: player.y + (Math.random() - 0.5) * 20,
                                    vx: 0, vy: -1,
                                    life: 20, color: '#88ff44', radius: 4
                                });
                            }
                        }
                        break;

                    case 'geyser':
                        if (now - h.lastFire > h.cooldown) {
                            h.firing = true;
                            h.lastFire = now;
                            // Fire burst effect
                            for (let p = 0; p < 15; p++) {
                                particles.push({
                                    x: h.x, y: h.y,
                                    vx: (Math.random() - 0.5) * 8,
                                    vy: -Math.random() * 10 - 5,
                                    life: 40, color: '#ff4400', radius: 6 + Math.random() * 4
                                });
                            }
                            playSound('explosion');
                        }
                        if (h.firing && now - h.lastFire < 500) {
                            if (dist < h.damageRadius && player.invincible < now) {
                                player.health -= h.damage * (1 - player.damageReduction);
                                player.invincible = now + 300;
                            }
                        } else {
                            h.firing = false;
                        }
                        break;

                    case 'turret':
                        if (dist < h.range && now - h.lastShot > h.fireRate) {
                            h.lastShot = now;
                            const angle = Math.atan2(player.y - h.y, player.x - h.x);
                            hazardProjectiles.push({
                                x: h.x, y: h.y,
                                vx: Math.cos(angle) * 6,
                                vy: Math.sin(angle) * 6,
                                damage: h.damage,
                                radius: 8
                            });
                            playSound('shoot');
                        }
                        break;
                }
            }

            // Update hazard projectiles
            for (let i = hazardProjectiles.length - 1; i >= 0; i--) {
                const p = hazardProjectiles[i];
                p.x += p.vx;
                p.y += p.vy;

                // Remove if off-map
                if (p.x < 0 || p.x > WORLD_WIDTH || p.y < 0 || p.y > WORLD_HEIGHT) {
                    hazardProjectiles.splice(i, 1);
                    continue;
                }

                // Hit player
                const dist = Math.hypot(player.x - p.x, player.y - p.y);
                if (dist < player.radius + p.radius && player.invincible < now) {
                    player.health -= p.damage * (1 - player.damageReduction);
                    player.invincible = now + 300;
                    playSound('playerHit');
                    hazardProjectiles.splice(i, 1);
                }
            }
        }

        // ===== TREASURE CHEST SYSTEM =====
        const TEMP_BUFFS = [
            { name: 'Damage Surge', desc: '+50% damage', duration: 15000, effect: 'damage', value: 0.5, color: '#ff4444' },
            { name: 'Speed Boost', desc: '+40% speed', duration: 12000, effect: 'speed', value: 0.4, color: '#44ff44' },
            { name: 'Shield', desc: 'Invincibility', duration: 5000, effect: 'invincible', value: 1, color: '#4444ff' },
            { name: 'Rapid Fire', desc: '+60% fire rate', duration: 10000, effect: 'fireRate', value: 0.6, color: '#ffff44' },
            { name: 'Giant', desc: '+100% size & damage', duration: 8000, effect: 'giant', value: 1, color: '#ff44ff' },
            { name: 'Magnet', desc: 'Max soul magnet', duration: 20000, effect: 'magnet', value: 500, color: '#ffd700' },
            { name: 'Vampiric Aura', desc: '+10% life steal', duration: 15000, effect: 'vampiric', value: 0.1, color: '#aa0000' },
            { name: 'Multi-Shot', desc: '+5 projectiles', duration: 12000, effect: 'multishot', value: 5, color: '#00ffff' }
        ];

        let activeBuffs = [];
        let chestSpawnTimer = 0;
        const CHEST_SPAWN_INTERVAL = 15000; // New chest every 15 seconds

        function spawnChest() {
            // Spawn away from player
            let x, y, attempts = 0;
            do {
                x = 200 + Math.random() * (WORLD_WIDTH - 400);
                y = 200 + Math.random() * (WORLD_HEIGHT - 400);
                attempts++;
            } while (Math.hypot(x - player.x, y - player.y) < 400 && attempts < 20);

            treasureChests.push({
                x, y,
                opened: false,
                buff: TEMP_BUFFS[Math.floor(Math.random() * TEMP_BUFFS.length)],
                bobOffset: Math.random() * Math.PI * 2
            });
        }

        function updateChests() {
            const now = Date.now();

            // Spawn new chests periodically during waves
            if (gameState === 'playing') {
                chestSpawnTimer += 16.67; // ~60fps
                if (chestSpawnTimer > CHEST_SPAWN_INTERVAL && treasureChests.length < 5) {
                    spawnChest();
                    chestSpawnTimer = 0;
                }
            }

            // Check chest collection
            for (let i = treasureChests.length - 1; i >= 0; i--) {
                const chest = treasureChests[i];
                if (chest.opened) continue;

                const dist = Math.hypot(player.x - chest.x, player.y - chest.y);
                if (dist < player.radius + 30) {
                    chest.opened = true;
                    // Apply buff
                    const buff = { ...chest.buff, endTime: now + chest.buff.duration };
                    activeBuffs.push(buff);
                    applyBuff(buff);
                    playSound('upgrade');

                    // Particle burst
                    for (let p = 0; p < 20; p++) {
                        particles.push({
                            x: chest.x, y: chest.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8 - 3,
                            life: 40, color: buff.color, radius: 5
                        });
                    }

                    treasureChests.splice(i, 1);
                }
            }

            // Update active buffs
            for (let i = activeBuffs.length - 1; i >= 0; i--) {
                if (now > activeBuffs[i].endTime) {
                    removeBuff(activeBuffs[i]);
                    activeBuffs.splice(i, 1);
                }
            }
        }

        function applyBuff(buff) {
            switch(buff.effect) {
                case 'damage': player.tempDamageBonus = (player.tempDamageBonus || 0) + buff.value; break;
                case 'speed': player.tempSpeedBonus = (player.tempSpeedBonus || 0) + buff.value; break;
                case 'invincible': player.invincible = Date.now() + buff.duration; break;
                case 'fireRate': player.tempFireRateBonus = (player.tempFireRateBonus || 0) + buff.value; break;
                case 'giant': player.tempSizeBonus = (player.tempSizeBonus || 0) + buff.value; break;
                case 'magnet': player.tempMagnetBonus = (player.tempMagnetBonus || 0) + buff.value; break;
                case 'vampiric': player.tempVampiricBonus = (player.tempVampiricBonus || 0) + buff.value; break;
                case 'multishot': player.tempMultishotBonus = (player.tempMultishotBonus || 0) + buff.value; break;
            }
        }

        function removeBuff(buff) {
            switch(buff.effect) {
                case 'damage': player.tempDamageBonus = Math.max(0, (player.tempDamageBonus || 0) - buff.value); break;
                case 'speed': player.tempSpeedBonus = Math.max(0, (player.tempSpeedBonus || 0) - buff.value); break;
                case 'fireRate': player.tempFireRateBonus = Math.max(0, (player.tempFireRateBonus || 0) - buff.value); break;
                case 'giant': player.tempSizeBonus = Math.max(0, (player.tempSizeBonus || 0) - buff.value); break;
                case 'magnet': player.tempMagnetBonus = Math.max(0, (player.tempMagnetBonus || 0) - buff.value); break;
                case 'vampiric': player.tempVampiricBonus = Math.max(0, (player.tempVampiricBonus || 0) - buff.value); break;
                case 'multishot': player.tempMultishotBonus = Math.max(0, (player.tempMultishotBonus || 0) - buff.value); break;
            }
        }

        // ===== TIME-BASED WAVE SYSTEM =====
        let waveTimer = 0;
        let waveTimeLimit = 60000; // 60 seconds per wave (increases each wave)
        let enemySpawnTimer = 0;
        let enemySpawnRate = 1500; // Spawn enemy every 1.5 seconds (decreases each wave)

        // ===== ENHANCED SOUND SYSTEM =====
        let audioCtx = null;
        let soundEnabled = true;
        let masterGain = null;
        let reverbNode = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.7;
                masterGain.connect(audioCtx.destination);

                // Create simple reverb
                const reverbTime = 0.3;
                const sampleRate = audioCtx.sampleRate;
                const length = sampleRate * reverbTime;
                const impulse = audioCtx.createBuffer(2, length, sampleRate);
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                reverbNode = audioCtx.createConvolver();
                reverbNode.buffer = impulse;
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function createNoise(duration) {
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            return noise;
        }

        function playSound(type, volume = 0.3) {
            if (!soundEnabled || !audioCtx) return;
            const now = audioCtx.currentTime;

            switch(type) {
                case 'shoot': {
                    // Layered laser with harmonics
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const osc3 = audioCtx.createOscillator();
                    const filter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(3000, now);
                    filter.frequency.exponentialRampToValueAtTime(500, now + 0.08);
                    filter.Q.value = 2;

                    osc1.type = 'sawtooth';
                    osc2.type = 'square';
                    osc3.type = 'sine';

                    osc1.frequency.setValueAtTime(880, now);
                    osc1.frequency.exponentialRampToValueAtTime(220, now + 0.08);
                    osc2.frequency.setValueAtTime(440, now);
                    osc2.frequency.exponentialRampToValueAtTime(110, now + 0.08);
                    osc3.frequency.setValueAtTime(1760, now);
                    osc3.frequency.exponentialRampToValueAtTime(440, now + 0.06);

                    const mix = audioCtx.createGain();
                    mix.gain.value = 0.33;

                    osc1.connect(mix);
                    osc2.connect(mix);
                    osc3.connect(mix);
                    mix.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(volume * 0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

                    osc1.start(now);
                    osc2.start(now);
                    osc3.start(now);
                    osc1.stop(now + 0.1);
                    osc2.stop(now + 0.1);
                    osc3.stop(now + 0.1);
                    break;
                }
                case 'hit': {
                    // Punchy impact with sub bass
                    const osc = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const noise = createNoise(0.1);
                    const filter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();
                    const noiseGain = audioCtx.createGain();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(800, now);
                    filter.frequency.exponentialRampToValueAtTime(100, now + 0.08);

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);

                    osc2.type = 'triangle';
                    osc2.frequency.setValueAtTime(400, now);
                    osc2.frequency.exponentialRampToValueAtTime(80, now + 0.08);

                    osc.connect(gain);
                    osc2.connect(gain);
                    noise.connect(filter);
                    filter.connect(noiseGain);
                    noiseGain.connect(gain);
                    gain.connect(masterGain);

                    noiseGain.gain.setValueAtTime(volume * 0.15, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                    gain.gain.setValueAtTime(volume * 0.35, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

                    osc.start(now);
                    osc2.start(now);
                    noise.start(now);
                    osc.stop(now + 0.12);
                    osc2.stop(now + 0.1);
                    noise.stop(now + 0.1);
                    break;
                }
                case 'kill': {
                    // Satisfying splat with body
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const osc3 = audioCtx.createOscillator();
                    const noise = createNoise(0.2);
                    const filter = audioCtx.createBiquadFilter();
                    const noiseFilter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1200, now);
                    filter.frequency.exponentialRampToValueAtTime(80, now + 0.2);
                    filter.Q.value = 3;

                    noiseFilter.type = 'bandpass';
                    noiseFilter.frequency.setValueAtTime(2000, now);
                    noiseFilter.frequency.exponentialRampToValueAtTime(400, now + 0.15);

                    osc1.type = 'sine';
                    osc1.frequency.setValueAtTime(500, now);
                    osc1.frequency.exponentialRampToValueAtTime(60, now + 0.2);

                    osc2.type = 'triangle';
                    osc2.frequency.setValueAtTime(300, now);
                    osc2.frequency.exponentialRampToValueAtTime(40, now + 0.18);

                    osc3.type = 'sawtooth';
                    osc3.frequency.setValueAtTime(150, now);
                    osc3.frequency.exponentialRampToValueAtTime(30, now + 0.15);

                    const oscGain = audioCtx.createGain();
                    oscGain.gain.value = 0.4;

                    osc1.connect(filter);
                    osc2.connect(filter);
                    osc3.connect(oscGain);
                    oscGain.connect(filter);
                    filter.connect(gain);
                    noise.connect(noiseFilter);
                    noiseFilter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(volume * 0.4, now);
                    gain.gain.setValueAtTime(volume * 0.4, now + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

                    osc1.start(now);
                    osc2.start(now);
                    osc3.start(now);
                    noise.start(now);
                    osc1.stop(now + 0.25);
                    osc2.stop(now + 0.2);
                    osc3.stop(now + 0.18);
                    noise.stop(now + 0.2);
                    break;
                }
                case 'playerHit': {
                    // Heavy impact with crunch
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const noise = createNoise(0.25);
                    const distortion = audioCtx.createWaveShaper();
                    const filter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    // Create distortion curve
                    const curve = new Float32Array(256);
                    for (let i = 0; i < 256; i++) {
                        const x = (i - 128) / 128;
                        curve[i] = Math.tanh(x * 3);
                    }
                    distortion.curve = curve;

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(2000, now);
                    filter.frequency.exponentialRampToValueAtTime(150, now + 0.25);

                    osc1.type = 'sawtooth';
                    osc1.frequency.setValueAtTime(150, now);
                    osc1.frequency.exponentialRampToValueAtTime(35, now + 0.25);

                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(75, now);
                    osc2.frequency.exponentialRampToValueAtTime(20, now + 0.2);

                    osc1.connect(distortion);
                    osc2.connect(distortion);
                    noise.connect(filter);
                    distortion.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(volume * 0.5, now);
                    gain.gain.setValueAtTime(volume * 0.45, now + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

                    osc1.start(now);
                    osc2.start(now);
                    noise.start(now);
                    osc1.stop(now + 0.3);
                    osc2.stop(now + 0.25);
                    noise.stop(now + 0.25);
                    break;
                }
                case 'explosion': {
                    // Massive layered explosion
                    const noise1 = createNoise(0.5);
                    const noise2 = createNoise(0.4);
                    const osc = audioCtx.createOscillator();
                    const lowFilter = audioCtx.createBiquadFilter();
                    const midFilter = audioCtx.createBiquadFilter();
                    const highFilter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    lowFilter.type = 'lowpass';
                    lowFilter.frequency.setValueAtTime(300, now);
                    lowFilter.frequency.exponentialRampToValueAtTime(40, now + 0.5);
                    lowFilter.Q.value = 1;

                    midFilter.type = 'bandpass';
                    midFilter.frequency.setValueAtTime(1500, now);
                    midFilter.frequency.exponentialRampToValueAtTime(200, now + 0.3);
                    midFilter.Q.value = 0.5;

                    highFilter.type = 'highpass';
                    highFilter.frequency.setValueAtTime(3000, now);
                    highFilter.frequency.exponentialRampToValueAtTime(800, now + 0.15);

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.exponentialRampToValueAtTime(20, now + 0.4);

                    const lowGain = audioCtx.createGain();
                    const midGain = audioCtx.createGain();
                    const highGain = audioCtx.createGain();

                    lowGain.gain.setValueAtTime(0.6, now);
                    lowGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    midGain.gain.setValueAtTime(0.4, now);
                    midGain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                    highGain.gain.setValueAtTime(0.3, now);
                    highGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

                    noise1.connect(lowFilter);
                    lowFilter.connect(lowGain);
                    osc.connect(lowGain);
                    noise1.connect(midFilter);
                    midFilter.connect(midGain);
                    noise2.connect(highFilter);
                    highFilter.connect(highGain);

                    lowGain.connect(gain);
                    midGain.connect(gain);
                    highGain.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(volume * 0.7, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

                    noise1.start(now);
                    noise2.start(now);
                    osc.start(now);
                    noise1.stop(now + 0.5);
                    noise2.stop(now + 0.4);
                    osc.stop(now + 0.45);
                    break;
                }
                case 'upgrade': {
                    // Magical chime with shimmer
                    const notes = [523, 659, 784, 1047, 1319];
                    notes.forEach((freq, i) => {
                        const osc = audioCtx.createOscillator();
                        const osc2 = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        const filter = audioCtx.createBiquadFilter();

                        filter.type = 'highpass';
                        filter.frequency.value = 400;

                        osc.type = 'sine';
                        osc2.type = 'triangle';
                        osc.frequency.setValueAtTime(freq, now + i * 0.08);
                        osc2.frequency.setValueAtTime(freq * 2.01, now + i * 0.08);

                        const mix = audioCtx.createGain();
                        mix.gain.value = 0.7;

                        osc.connect(gain);
                        osc2.connect(mix);
                        mix.connect(gain);
                        gain.connect(filter);
                        filter.connect(masterGain);

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.setValueAtTime(volume * 0.2, now + i * 0.08);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.5);

                        osc.start(now + i * 0.08);
                        osc2.start(now + i * 0.08);
                        osc.stop(now + i * 0.08 + 0.5);
                        osc2.stop(now + i * 0.08 + 0.5);
                    });
                    break;
                }
                case 'waveStart': {
                    // Epic horn with reverb
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const osc3 = audioCtx.createOscillator();
                    const filter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(800, now);
                    filter.frequency.linearRampToValueAtTime(2000, now + 0.3);
                    filter.frequency.linearRampToValueAtTime(1200, now + 0.8);

                    osc1.type = 'sawtooth';
                    osc2.type = 'sawtooth';
                    osc3.type = 'square';

                    osc1.frequency.setValueAtTime(220, now);
                    osc1.frequency.setValueAtTime(330, now + 0.25);
                    osc1.frequency.setValueAtTime(440, now + 0.5);

                    osc2.frequency.setValueAtTime(221, now);
                    osc2.frequency.setValueAtTime(331, now + 0.25);
                    osc2.frequency.setValueAtTime(441, now + 0.5);

                    osc3.frequency.setValueAtTime(110, now);
                    osc3.frequency.setValueAtTime(165, now + 0.25);
                    osc3.frequency.setValueAtTime(220, now + 0.5);

                    const mix = audioCtx.createGain();
                    mix.gain.value = 0.33;

                    osc1.connect(mix);
                    osc2.connect(mix);
                    osc3.connect(mix);
                    mix.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(0.001, now);
                    gain.gain.exponentialRampToValueAtTime(volume * 0.35, now + 0.1);
                    gain.gain.setValueAtTime(volume * 0.35, now + 0.6);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.9);

                    osc1.start(now);
                    osc2.start(now);
                    osc3.start(now);
                    osc1.stop(now + 0.9);
                    osc2.stop(now + 0.9);
                    osc3.stop(now + 0.9);
                    break;
                }
                case 'waveComplete': {
                    // Triumphant fanfare
                    const chords = [
                        [523, 659, 784],
                        [587, 740, 880],
                        [659, 784, 988],
                        [784, 988, 1175, 1568]
                    ];
                    chords.forEach((chord, i) => {
                        chord.forEach(freq => {
                            const osc = audioCtx.createOscillator();
                            const osc2 = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            const filter = audioCtx.createBiquadFilter();

                            filter.type = 'lowpass';
                            filter.frequency.value = 3000;

                            osc.type = 'triangle';
                            osc2.type = 'sine';
                            osc.frequency.value = freq;
                            osc2.frequency.value = freq * 2;

                            osc.connect(gain);
                            osc2.connect(gain);
                            gain.connect(filter);
                            filter.connect(masterGain);

                            const startTime = now + i * 0.15;
                            gain.gain.setValueAtTime(0, now);
                            gain.gain.linearRampToValueAtTime(volume * 0.15, startTime + 0.02);
                            gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);

                            osc.start(startTime);
                            osc2.start(startTime);
                            osc.stop(startTime + 0.5);
                            osc2.stop(startTime + 0.5);
                        });
                    });
                    break;
                }
                case 'gameOver': {
                    // Dramatic death with dissonance
                    const notes = [392, 370, 349, 311, 294, 262];
                    notes.forEach((freq, i) => {
                        const osc = audioCtx.createOscillator();
                        const osc2 = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        const filter = audioCtx.createBiquadFilter();

                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(2000, now + i * 0.2);
                        filter.frequency.exponentialRampToValueAtTime(400, now + i * 0.2 + 0.5);

                        osc.type = 'sawtooth';
                        osc2.type = 'sine';
                        osc.frequency.value = freq;
                        osc2.frequency.value = freq * 0.5;

                        const mix = audioCtx.createGain();
                        mix.gain.value = 0.5;

                        osc.connect(mix);
                        osc2.connect(gain);
                        mix.connect(filter);
                        filter.connect(gain);
                        gain.connect(masterGain);

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(volume * 0.25, now + i * 0.2 + 0.05);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.2 + 0.6);

                        osc.start(now + i * 0.2);
                        osc2.start(now + i * 0.2);
                        osc.stop(now + i * 0.2 + 0.6);
                        osc2.stop(now + i * 0.2 + 0.6);
                    });
                    break;
                }
                case 'bossSpawn': {
                    // Massive ominous rumble
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const osc3 = audioCtx.createOscillator();
                    const noise = createNoise(1.5);
                    const lfo = audioCtx.createOscillator();
                    const lfoGain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, now);
                    filter.frequency.linearRampToValueAtTime(400, now + 0.5);
                    filter.frequency.linearRampToValueAtTime(100, now + 1.5);

                    lfo.frequency.value = 4;
                    lfoGain.gain.value = 10;
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc1.frequency);

                    osc1.type = 'sawtooth';
                    osc2.type = 'sine';
                    osc3.type = 'triangle';
                    osc1.frequency.setValueAtTime(55, now);
                    osc2.frequency.setValueAtTime(55.5, now);
                    osc3.frequency.setValueAtTime(27.5, now);

                    const noiseFilter = audioCtx.createBiquadFilter();
                    noiseFilter.type = 'lowpass';
                    noiseFilter.frequency.value = 150;

                    osc1.connect(filter);
                    osc2.connect(filter);
                    osc3.connect(filter);
                    noise.connect(noiseFilter);
                    noiseFilter.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(0.001, now);
                    gain.gain.exponentialRampToValueAtTime(volume * 0.5, now + 0.4);
                    gain.gain.setValueAtTime(volume * 0.5, now + 0.8);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);

                    lfo.start(now);
                    osc1.start(now);
                    osc2.start(now);
                    osc3.start(now);
                    noise.start(now);
                    lfo.stop(now + 1.5);
                    osc1.stop(now + 1.5);
                    osc2.stop(now + 1.5);
                    osc3.stop(now + 1.5);
                    noise.stop(now + 1.5);
                    break;
                }
                case 'teleport': {
                    // Mystical whoosh with sparkle
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const noise = createNoise(0.2);
                    const filter = audioCtx.createBiquadFilter();
                    const noiseFilter = audioCtx.createBiquadFilter();
                    const gain = audioCtx.createGain();

                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(3000, now);
                    filter.frequency.exponentialRampToValueAtTime(200, now + 0.2);
                    filter.Q.value = 5;

                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.setValueAtTime(4000, now);
                    noiseFilter.frequency.exponentialRampToValueAtTime(1000, now + 0.15);

                    osc1.type = 'sine';
                    osc2.type = 'triangle';
                    osc1.frequency.setValueAtTime(2500, now);
                    osc1.frequency.exponentialRampToValueAtTime(150, now + 0.2);
                    osc2.frequency.setValueAtTime(1800, now);
                    osc2.frequency.exponentialRampToValueAtTime(100, now + 0.18);

                    osc1.connect(filter);
                    osc2.connect(filter);
                    noise.connect(noiseFilter);
                    noiseFilter.connect(gain);
                    filter.connect(gain);
                    gain.connect(masterGain);

                    gain.gain.setValueAtTime(volume * 0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.22);

                    osc1.start(now);
                    osc2.start(now);
                    noise.start(now);
                    osc1.stop(now + 0.22);
                    osc2.stop(now + 0.2);
                    noise.stop(now + 0.2);
                    break;
                }
            }
        }

        // Game state
        let gameState = 'start';
        let score = 0;
        let souls = 0;
        let wave = 1;
        let enemiesRemaining = 0;
        let selectedClass = null;

        // Input
        const keys = {};
        let mouseX = W / 2;      // Screen coordinates
        let mouseY = H / 2;
        let worldMouseX = 0;     // World coordinates (computed each frame)
        let worldMouseY = 0;
        let mouseDown = false;

        // Class definitions
        const classDefinitions = {
            mage: {
                name: 'Mage',
                color: '#9370db',
                secondaryColor: '#6a5acd',
                health: 80,
                speed: 4.5,
                fireRate: 180,
                bulletDamage: 15,
                bulletSpeed: 14,
                bulletSize: 6,
                bulletCount: 1,
                bulletPierce: 2,
                bulletRange: 600,
                tracking: 0,
                critChance: 0.05,
                critMultiplier: 2,
                damageReduction: 0,
                lifeRegen: 0,
                projectileType: 'magic',
                ability: 'arcaneNova',
                abilityName: 'Arcane Nova',
                abilityDesc: 'AoE magic burst',
                abilityCooldown: 8000,
                abilityDamage: 100,
                abilityRadius: 150
            },
            barbarian: {
                name: 'Barbarian',
                color: '#dc143c',
                secondaryColor: '#8b0000',
                health: 150,
                speed: 4,
                fireRate: 300,
                bulletDamage: 25,
                bulletSpeed: 10,
                bulletSize: 10,
                bulletCount: 1,
                bulletPierce: 1,
                bulletRange: 350,
                tracking: 0,
                critChance: 0.1,
                critMultiplier: 1.5,
                damageReduction: 0.1,
                lifeRegen: 0,
                projectileType: 'axe',
                ability: 'battleRage',
                abilityName: 'Battle Rage',
                abilityDesc: 'Damage & speed buff',
                abilityCooldown: 12000,
                abilityDuration: 5000,
                abilityDamageBuff: 0.5,
                abilitySpeedBuff: 0.3
            },
            ninja: {
                name: 'Ninja',
                color: '#5f9f9f',
                secondaryColor: '#2f4f4f',
                health: 90,
                speed: 7,
                fireRate: 120,
                bulletDamage: 8,
                bulletSpeed: 16,
                bulletSize: 4,
                bulletCount: 3,
                bulletPierce: 1,
                bulletRange: 450,
                tracking: 0,
                critChance: 0.25,
                critMultiplier: 2.5,
                damageReduction: 0,
                lifeRegen: 0,
                projectileType: 'shuriken',
                ability: 'shadowStep',
                abilityName: 'Shadow Step',
                abilityDesc: 'Dash with invincibility',
                abilityCooldown: 6000,
                abilityDistance: 200,
                abilityInvincibility: 500,
                abilityTrailDamage: 30
            },
            knight: {
                name: 'Knight',
                color: '#ffd700',
                secondaryColor: '#b8860b',
                health: 120,
                speed: 4.5,
                fireRate: 200,
                bulletDamage: 12,
                bulletSpeed: 12,
                bulletSize: 7,
                bulletCount: 1,
                bulletPierce: 1,
                bulletRange: 400,
                tracking: 0,
                critChance: 0.08,
                critMultiplier: 1.8,
                damageReduction: 0.2,
                lifeRegen: 0.5,
                projectileType: 'sword',
                ability: 'shieldWall',
                abilityName: 'Shield Wall',
                abilityDesc: 'Block & reflect damage',
                abilityCooldown: 10000,
                abilityDuration: 3000,
                abilityDamageReduction: 0.8,
                abilityReflect: 0.3
            }
        };

        // Diminishing returns helper - returns multiplier based on level (0.88^level)
        const DR = 0.88; // Each level gives 88% of the previous level's bonus
        function diminish(baseValue, level) {
            return baseValue * Math.pow(DR, level);
        }

        // Class-specific upgrades with diminishing returns
        const classUpgrades = {
            mage: [
                { id: 'arcaneBlast', name: 'Arcane Blast', desc: 'Pierce & damage (diminishing)', cost: 30, costMult: 1.8, level: 0, maxLevel: 8,
                  apply: function() { const d = diminish(1, this.level - 1); player.bulletPierce += Math.max(1, Math.floor(3 * d)); player.bulletDamage += 5 * d; } },
                { id: 'manaFlow', name: 'Mana Flow', desc: 'Attack speed (diminishing)', cost: 20, costMult: 1.5, level: 0, maxLevel: 10,
                  apply: function() { const d = diminish(0.15, this.level - 1); player.fireRate *= (1 - d); } },
                { id: 'spellSize', name: 'Spell Amplify', desc: 'Projectile size (diminishing)', cost: 15, costMult: 1.4, level: 0, maxLevel: 10,
                  apply: function() { player.bulletSize += diminish(4, this.level - 1); } }
            ],
            barbarian: [
                { id: 'rage', name: 'Berserker Rage', desc: 'Low HP damage (diminishing)', cost: 25, costMult: 1.6, level: 0, maxLevel: 10,
                  apply: function() { player.rageDamage = (player.rageDamage || 0) + diminish(0.2, this.level - 1); } },
                { id: 'cleave', name: 'Cleaving Axes', desc: 'Pierce (diminishing)', cost: 35, costMult: 1.8, level: 0, maxLevel: 6,
                  apply: function() { player.bulletPierce += Math.max(1, Math.floor(diminish(2, this.level - 1))); } },
                { id: 'warcry', name: 'War Cry', desc: 'Max health (diminishing)', cost: 20, costMult: 1.4, level: 0, maxLevel: 15,
                  apply: function() { const hp = diminish(30, this.level - 1); player.maxHealth += hp; player.health += hp; } }
            ],
            ninja: [
                { id: 'swiftStrike', name: 'Swift Strike', desc: 'Extra shurikens (diminishing)', cost: 30, costMult: 2, level: 0, maxLevel: 6,
                  apply: function() { player.bulletCount += Math.max(1, Math.floor(diminish(2, this.level - 1))); } },
                { id: 'deadlyPrecision', name: 'Deadly Precision', desc: 'Crit chance/damage (diminishing)', cost: 25, costMult: 1.6, level: 0, maxLevel: 8,
                  apply: function() { const d = diminish(1, this.level - 1); player.critChance += 0.1 * d; player.critMultiplier += 0.5 * d; } },
                { id: 'shadowSpeed', name: 'Shadow Speed', desc: 'Move speed (diminishing)', cost: 15, costMult: 1.5, level: 0, maxLevel: 10,
                  apply: function() { player.speed += diminish(1, this.level - 1); } }
            ],
            knight: [
                { id: 'fortify', name: 'Fortify', desc: 'Damage reduction (diminishing)', cost: 25, costMult: 1.6, level: 0, maxLevel: 8,
                  apply: function() { player.damageReduction = Math.min(0.75, player.damageReduction + diminish(0.1, this.level - 1)); } },
                { id: 'holyBlade', name: 'Holy Blade', desc: 'Damage & regen (diminishing)', cost: 30, costMult: 1.7, level: 0, maxLevel: 10,
                  apply: function() { const d = diminish(1, this.level - 1); player.bulletDamage += 8 * d; player.lifeRegen += 1 * d; } },
                { id: 'bulwark', name: 'Bulwark', desc: 'Max health (diminishing)', cost: 20, costMult: 1.4, level: 0, maxLevel: 12,
                  apply: function() { const hp = diminish(40, this.level - 1); player.maxHealth += hp; player.health += hp; } }
            ]
        };

        // Universal upgrades with diminishing returns
        const universalUpgrades = [
            { id: 'damage', name: 'Attack Power', desc: 'Damage (diminishing)', cost: 10, costMult: 1.5, level: 0, maxLevel: 20,
              apply: function() { player.bulletDamage += diminish(5, this.level - 1); } },
            { id: 'fireRate', name: 'Attack Speed', desc: 'Fire rate (diminishing)', cost: 15, costMult: 1.4, level: 0, maxLevel: 15,
              apply: function() { player.fireRate *= (1 - diminish(0.08, this.level - 1)); } },
            { id: 'bulletCount', name: 'Multi-Shot', desc: '+1 projectile', cost: 25, costMult: 2.2, level: 0, maxLevel: 6,
              apply: function() { player.bulletCount += 1; } }, // No diminishing - always +1
            { id: 'tracking', name: 'Homing', desc: 'Tracking (max 50%)', cost: 30, costMult: 1.6, level: 0, maxLevel: 10,
              apply: function() { player.tracking = Math.min(0.5, player.tracking + diminish(0.08, this.level - 1)); } },
            { id: 'stun', name: 'Stun Effect', desc: 'Stun chance (diminishing)', cost: 20, costMult: 1.5, level: 0, maxLevel: 10,
              apply: function() { player.stunChance = Math.min(0.8, (player.stunChance || 0) + diminish(0.1, this.level - 1)); } },
            { id: 'explosive', name: 'Explosive', desc: 'Explosion chance (diminishing)', cost: 40, costMult: 1.7, level: 0, maxLevel: 8,
              apply: function() { player.explosiveChance = Math.min(0.6, (player.explosiveChance || 0) + diminish(0.08, this.level - 1)); } },
            { id: 'vampiric', name: 'Life Steal', desc: 'Life steal (diminishing)', cost: 50, costMult: 1.8, level: 0, maxLevel: 10,
              apply: function() { player.vampiric = Math.min(0.15, (player.vampiric || 0) + diminish(0.02, this.level - 1)); } },
            { id: 'maxHealth', name: 'Vitality', desc: 'Max health (diminishing)', cost: 15, costMult: 1.4, level: 0, maxLevel: 20,
              apply: function() { const hp = diminish(20, this.level - 1); player.maxHealth += hp; player.health += hp; } },
            { id: 'speed', name: 'Swiftness', desc: 'Move speed (diminishing)', cost: 10, costMult: 1.3, level: 0, maxLevel: 15,
              apply: function() { player.speed += diminish(0.4, this.level - 1); } },
            { id: 'range', name: 'Extended Range', desc: 'Range (diminishing)', cost: 12, costMult: 1.3, level: 0, maxLevel: 12,
              apply: function() { player.rangeBonus += diminish(50, this.level - 1); } },
            { id: 'abilityPower', name: 'Ability Power', desc: 'Ability power (diminishing)', cost: 35, costMult: 1.6, level: 0, maxLevel: 10,
              apply: function() { player.abilityPower += diminish(0.15, this.level - 1); } },
            { id: 'abilityCooldown', name: 'Ability Haste', desc: 'Cooldown reduction (diminishing)', cost: 30, costMult: 1.5, level: 0, maxLevel: 8,
              apply: function() { player.abilityCooldownMult *= (1 - diminish(0.1, this.level - 1)); } },
            { id: 'abilityDuration', name: 'Ability Duration', desc: 'Duration (diminishing)', cost: 25, costMult: 1.5, level: 0, maxLevel: 8,
              apply: function() { player.abilityDurationMult += diminish(0.15, this.level - 1); } },
            // New mechanics
            { id: 'critChain', name: 'Chain Lightning', desc: 'Crits chain to nearby enemies', cost: 45, costMult: 1.8, level: 0, maxLevel: 5,
              apply: function() { player.critChainCount = (player.critChainCount || 0) + 1; player.critChainDamage = (player.critChainDamage || 0.3) + diminish(0.1, this.level - 1); } },
            { id: 'soulMagnet', name: 'Soul Magnet', desc: 'Auto-collect souls in radius', cost: 20, costMult: 1.4, level: 0, maxLevel: 8,
              apply: function() { player.soulMagnetRadius = (player.soulMagnetRadius || 0) + diminish(60, this.level - 1); } },
            { id: 'ricochet', name: 'Ricochet', desc: 'Projectiles bounce off walls', cost: 35, costMult: 1.7, level: 0, maxLevel: 4,
              apply: function() { player.ricochetCount = (player.ricochetCount || 0) + 1; } },
            { id: 'execute', name: 'Executioner', desc: 'Bonus damage to low HP enemies', cost: 30, costMult: 1.6, level: 0, maxLevel: 6,
              apply: function() { player.executeDamage = (player.executeDamage || 0) + diminish(0.25, this.level - 1); } },
            { id: 'combo', name: 'Combo Master', desc: 'Consecutive hits boost damage', cost: 25, costMult: 1.5, level: 0, maxLevel: 8,
              apply: function() { player.comboBonus = (player.comboBonus || 0) + diminish(0.03, this.level - 1); player.comboMax = (player.comboMax || 10) + 5; } }
        ];

        let currentUpgrades = [];

        // Player
        let player = {};

        function initPlayer(classType) {
            const classDef = classDefinitions[classType];
            player = {
                x: WORLD_WIDTH / 2,  // Start in world center
                y: WORLD_HEIGHT / 2,
                radius: 20,
                class: classType,
                ...classDef,
                maxHealth: classDef.health,
                invincible: 0,
                lastShot: 0,
                bulletSpread: 0.15,
                stunChance: 0,
                stunDuration: 500,
                explosiveChance: 0,
                explosiveRadius: 60,
                vampiric: 0,
                rageDamage: 0,
                // Ability state
                abilityCooldownEnd: 0,
                abilityActive: false,
                abilityActiveEnd: 0,
                // Ability upgrades (multiplicative modifiers)
                abilityPower: 1.0,
                abilityCooldownMult: 1.0,
                abilityDurationMult: 1.0,
                // Range upgrade
                rangeBonus: 0,
                // Battle Rage specific
                rageActive: false,
                rageDamageBonus: 0,
                rageSpeedBonus: 0,
                // Shield Wall specific
                shieldActive: false,
                shieldDamageReduction: 0,
                shieldReflect: 0,
                // New mechanics
                critChainCount: 0,
                critChainDamage: 0.3,
                soulMagnetRadius: 0,
                ricochetCount: 0,
                executeDamage: 0,
                comboBonus: 0,
                comboMax: 10,
                comboCount: 0,
                lastHitTime: 0,
                // Temporary buff bonuses
                tempDamageBonus: 0,
                tempSpeedBonus: 0,
                tempFireRateBonus: 0,
                tempSizeBonus: 0,
                tempMagnetBonus: 0,
                tempVampiricBonus: 0,
                tempMultishotBonus: 0
            };
            // Initialize camera to center on player
            camera.x = player.x - W / 2;
            camera.y = player.y - H / 2;
        }

        // Soul orbs for collection
        let soulOrbs = [];

        // Bullets
        let bullets = [];
        const maxBullets = 2000;

        // Enemies - D&D and Mythology creatures
        let enemies = [];
        const enemyTypes = {
            goblin: {
                name: 'Goblin',
                radius: 14,
                speed: 2.5,
                health: 25,
                damage: 8,
                color: '#5a8a32',
                soulValue: 2
            },
            skeleton: {
                name: 'Skeleton',
                radius: 16,
                speed: 2,
                health: 30,
                damage: 10,
                color: '#e8e8d8',
                soulValue: 2
            },
            orc: {
                name: 'Orc',
                radius: 22,
                speed: 1.8,
                health: 60,
                damage: 15,
                color: '#4a6a2a',
                soulValue: 4
            },
            harpy: {
                name: 'Harpy',
                radius: 18,
                speed: 4,
                health: 35,
                damage: 12,
                color: '#8b668b',
                soulValue: 4
            },
            minotaur: {
                name: 'Minotaur',
                radius: 28,
                speed: 2.5,
                health: 100,
                damage: 25,
                color: '#6b4423',
                soulValue: 8
            },
            wraith: {
                name: 'Wraith',
                radius: 20,
                speed: 2.2,
                health: 45,
                damage: 15,
                color: 'rgba(100, 100, 150, 0.7)',
                soulValue: 5,
                special: 'phase'
            },
            basilisk: {
                name: 'Basilisk',
                radius: 24,
                speed: 1.5,
                health: 80,
                damage: 20,
                color: '#2d5a27',
                soulValue: 6
            },
            vampire: {
                name: 'Vampire',
                radius: 20,
                speed: 3,
                health: 70,
                damage: 18,
                color: '#4a0a2a',
                soulValue: 7,
                special: 'teleport'
            },
            lich: {
                name: 'Lich',
                radius: 22,
                speed: 1.5,
                health: 90,
                damage: 22,
                color: '#3a1a5a',
                soulValue: 10,
                special: 'summon'
            },
            cyclops: {
                name: 'Cyclops',
                radius: 35,
                speed: 1.2,
                health: 180,
                damage: 30,
                color: '#7a6a5a',
                soulValue: 15
            },
            hydra: {
                name: 'Hydra',
                radius: 40,
                speed: 1,
                health: 250,
                damage: 28,
                color: '#2a6a4a',
                soulValue: 20,
                special: 'regen'
            },
            dragon: {
                name: 'Dragon',
                radius: 50,
                speed: 1.5,
                health: 400,
                damage: 40,
                color: '#8b0000',
                soulValue: 35,
                special: 'fireBreath'
            },
            beholder: {
                name: 'Beholder',
                radius: 32,
                speed: 1.8,
                health: 140,
                damage: 22,
                color: '#8b4513',
                soulValue: 18,
                special: 'eyebeam'
            },
            golem: {
                name: 'Stone Golem',
                radius: 38,
                speed: 0.8,
                health: 300,
                damage: 35,
                color: '#696969',
                soulValue: 22
            },
            banshee: {
                name: 'Banshee',
                radius: 22,
                speed: 2.8,
                health: 55,
                damage: 18,
                color: '#e0e0ff',
                soulValue: 8,
                special: 'scream'
            },
            werewolf: {
                name: 'Werewolf',
                radius: 26,
                speed: 4.5,
                health: 85,
                damage: 22,
                color: '#4a4a4a',
                soulValue: 12
            },
            demon: {
                name: 'Demon',
                radius: 30,
                speed: 2.2,
                health: 160,
                damage: 28,
                color: '#8b0000',
                soulValue: 16,
                special: 'flames'
            },
            fireElemental: {
                name: 'Fire Elemental',
                radius: 28,
                speed: 2.5,
                health: 90,
                damage: 20,
                color: '#ff4500',
                soulValue: 11,
                special: 'burning'
            },
            troll: {
                name: 'Troll',
                radius: 34,
                speed: 1.4,
                health: 200,
                damage: 26,
                color: '#556b2f',
                soulValue: 14,
                special: 'regen'
            },
            medusa: {
                name: 'Medusa',
                radius: 24,
                speed: 1.6,
                health: 110,
                damage: 20,
                color: '#228b22',
                soulValue: 13,
                special: 'petrify'
            },
            griffin: {
                name: 'Griffin',
                radius: 30,
                speed: 3.5,
                health: 120,
                damage: 24,
                color: '#daa520',
                soulValue: 15
            },
            necromancer: {
                name: 'Necromancer',
                radius: 22,
                speed: 1.2,
                health: 70,
                damage: 15,
                color: '#2f1f4f',
                soulValue: 12,
                special: 'summon'
            }
        };

        // Particles
        let particles = [];

        // Initialize
        function init() {
            document.querySelectorAll('.class-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.class-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedClass = btn.dataset.class;
                    document.getElementById('startBtn').classList.add('enabled');
                };
            });

            document.getElementById('startBtn').onclick = startGame;
            document.getElementById('startWaveBtn').onclick = startWave;
            document.getElementById('restartBtn').onclick = restartGame;

            document.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if (e.code === 'Space' && gameState === 'playing') {
                    e.preventDefault();
                    activateAbility();
                }
            });
            document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            });
            canvas.addEventListener('mousedown', () => mouseDown = true);
            canvas.addEventListener('mouseup', () => mouseDown = false);

            gameLoop();
        }

        function startGame() {
            if (!selectedClass) return;
            initAudio();
            initPlayer(selectedClass);

            // Generate the fantasy forest map
            generateMap();

            // Reset camera to center on player
            camera.x = player.x - W / 2;
            camera.y = player.y - H / 2;

            // Reset time-based wave variables
            waveTimer = 0;
            enemySpawnTimer = 0;
            chestSpawnTimer = 0;

            // Setup upgrades for this class
            currentUpgrades = [
                ...classUpgrades[selectedClass].map(u => ({...u})),
                ...universalUpgrades.map(u => ({...u}))
            ];

            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('classDisplay').textContent = `Class: ${classDefinitions[selectedClass].name}`;
            gameState = 'upgrading';
            showUpgradeMenu();
        }

        function restartGame() {
            score = 0;
            souls = 0;
            wave = 1;
            bullets = [];
            enemies = [];
            particles = [];
            soulOrbs = [];
            hazards = [];
            treasureChests = [];
            hazardProjectiles = [];
            activeBuffs = [];
            mapProps = [];
            selectedClass = null;

            // Reset camera
            camera.x = 0;
            camera.y = 0;

            // Reset wave timers
            waveTimer = 0;
            enemySpawnTimer = 0;
            chestSpawnTimer = 0;

            document.querySelectorAll('.class-btn').forEach(b => b.classList.remove('selected'));
            document.getElementById('startBtn').classList.remove('enabled');
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            gameState = 'start';
        }

        function showUpgradeMenu() {
            const menu = document.getElementById('upgradeMenu');
            const grid = document.getElementById('upgradeGrid');
            document.getElementById('soulsDisplay').textContent = `Souls: ${souls}`;

            // Update button text based on wave
            const waveBtn = document.getElementById('startWaveBtn');
            waveBtn.textContent = wave === 1 ? 'START' : `START WAVE ${wave}`;

            grid.innerHTML = '';
            currentUpgrades.forEach(upgrade => {
                const cost = Math.floor(upgrade.cost * Math.pow(upgrade.costMult, upgrade.level));
                const btn = document.createElement('button');
                btn.className = 'upgrade-btn';
                btn.disabled = souls < cost || upgrade.level >= upgrade.maxLevel;
                btn.innerHTML = `
                    <div class="name">${upgrade.name}</div>
                    <div class="desc">${upgrade.desc}</div>
                    <div class="cost">Cost: ${cost} souls</div>
                    <div class="level">Level: ${upgrade.level}/${upgrade.maxLevel}</div>
                `;
                btn.onclick = () => {
                    if (souls >= cost && upgrade.level < upgrade.maxLevel) {
                        souls -= cost;
                        upgrade.level++;
                        upgrade.apply();
                        playSound('upgrade');
                        showUpgradeMenu();
                    }
                };
                grid.appendChild(btn);
            });

            menu.style.display = 'block';
        }

        function startWave() {
            document.getElementById('upgradeMenu').style.display = 'none';
            gameState = 'playing';
            playSound('waveStart');

            // Initialize time-based wave system
            waveTimer = 0;
            enemySpawnTimer = 0;

            // Wave difficulty scaling
            waveTimeLimit = 45000 + wave * 15000; // 45s + 15s per wave (60s wave 1, 75s wave 2, etc)
            enemySpawnRate = Math.max(400, 1500 - wave * 100); // Faster spawns each wave (min 400ms)

            // Clear remaining enemies from previous wave
            enemies = [];
            enemiesRemaining = 0;

            // Spawn initial chests for the wave
            for (let i = 0; i < 2 + Math.floor(wave / 2); i++) {
                spawnChest();
            }

            // Spawn initial batch of enemies
            for (let i = 0; i < 3 + wave; i++) {
                spawnEnemy();
            }

            // Boss every 5 waves (spawns mid-wave)
            if (wave % 5 === 0) {
                setTimeout(() => {
                    if (gameState !== 'playing') return;
                    playSound('bossSpawn');
                    spawnBoss();
                }, waveTimeLimit / 2);
            }
        }

        function getSpawnPosition() {
            // Spawn enemies off-screen but around the player (world coordinates)
            let x, y;
            let attempts = 0;
            do {
                const angle = Math.random() * Math.PI * 2;
                const distance = ENEMY_SPAWN_DISTANCE + Math.random() * 200;
                x = player.x + Math.cos(angle) * distance;
                y = player.y + Math.sin(angle) * distance;

                // Clamp to world bounds
                x = Math.max(50, Math.min(WORLD_WIDTH - 50, x));
                y = Math.max(50, Math.min(WORLD_HEIGHT - 50, y));

                attempts++;
            } while (Math.hypot(x - player.x, y - player.y) < SPAWN_PROTECTION_RADIUS && attempts < 20);
            return { x, y };
        }

        function spawnEnemy() {
            if (gameState !== 'playing') return;

            const types = Object.keys(enemyTypes);
            let typeIndex = Math.floor(Math.random() * Math.min(wave + 1, types.length));
            const type = types[typeIndex];
            const template = enemyTypes[type];

            const pos = getSpawnPosition();
            const healthMult = 1 + (wave - 1) * 0.15;

            enemies.push({
                x: pos.x,
                y: pos.y,
                type,
                radius: template.radius,
                speed: template.speed,
                health: template.health * healthMult,
                maxHealth: template.health * healthMult,
                damage: template.damage,
                color: template.color,
                soulValue: template.soulValue,
                special: template.special,
                stunned: 0,
                teleportCooldown: 0,
                phaseTimer: 0,
                summonCooldown: 0,
                regenTimer: 0
            });
        }

        function spawnBoss() {
            const bossHealth = 600 * wave;
            const pos = getSpawnPosition();
            enemies.push({
                x: pos.x,
                y: pos.y,
                type: 'dragon',
                radius: 60 + wave * 2,
                speed: 0.8,
                health: bossHealth,
                maxHealth: bossHealth,
                damage: 50,
                color: '#8b0000',
                soulValue: 50 + wave * 10,
                special: 'fireBreath',
                isBoss: true,
                stunned: 0
            });
        }

        // Legacy function kept for compatibility
        function spawnWave() {
            // Now handled by continuous spawning in gameLoop
        }

        function shoot() {
            const now = Date.now();
            // Apply temp fire rate bonus
            const effectiveFireRate = player.fireRate * (1 - (player.tempFireRateBonus || 0));
            if (now - player.lastShot < effectiveFireRate) return;
            player.lastShot = now;

            playSound('shoot');

            // Use world coordinates for aiming
            const baseAngle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);

            // Calculate damage multiplier (passive + active + temp bonuses)
            let damageMultiplier = 1 + (player.tempDamageBonus || 0);
            if (player.rageDamage && player.health < player.maxHealth * 0.5) {
                damageMultiplier += player.rageDamage;
            }
            if (player.rageActive && player.rageDamageBonus > 0) {
                damageMultiplier += player.rageDamageBonus;
            }
            // Giant buff doubles damage too
            if (player.tempSizeBonus > 0) {
                damageMultiplier += player.tempSizeBonus;
            }

            // Calculate bullet count with temp bonus
            const totalBullets = player.bulletCount + (player.tempMultishotBonus || 0);
            const effectiveSize = player.bulletSize * (1 + (player.tempSizeBonus || 0));

            for (let i = 0; i < totalBullets; i++) {
                if (bullets.length >= maxBullets) bullets.shift();

                const spreadAngle = (i - (totalBullets - 1) / 2) * player.bulletSpread;
                const angle = baseAngle + spreadAngle + (Math.random() - 0.5) * 0.05;

                const isCrit = Math.random() < player.critChance;

                bullets.push({
                    x: player.x,
                    y: player.y,
                    startX: player.x,
                    startY: player.y,
                    vx: Math.cos(angle) * player.bulletSpeed,
                    vy: Math.sin(angle) * player.bulletSpeed,
                    radius: effectiveSize,
                    damage: player.bulletDamage * damageMultiplier * (isCrit ? player.critMultiplier : 1),
                    pierce: player.bulletPierce,
                    isCrit,
                    tracking: player.tracking,
                    stun: Math.random() < (player.stunChance || 0),
                    explosive: Math.random() < (player.explosiveChance || 0),
                    type: player.projectileType,
                    angle: angle,
                    maxRange: player.bulletRange + player.rangeBonus
                });
            }
        }

        function activateAbility() {
            const now = Date.now();

            // Check cooldown
            if (now < player.abilityCooldownEnd) {
                return;
            }

            const classDef = classDefinitions[player.class];
            const cooldown = classDef.abilityCooldown * player.abilityCooldownMult;

            switch(classDef.ability) {
                case 'arcaneNova': {
                    // Mage: AoE magic explosion around player
                    const radius = classDef.abilityRadius * player.abilityPower;
                    const damage = classDef.abilityDamage * player.abilityPower;

                    playSound('explosion');

                    // Create visual effect
                    for (let i = 0; i < 30; i++) {
                        const angle = (i / 30) * Math.PI * 2;
                        for (let d = 0; d < 3; d++) {
                            particles.push({
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(angle) * (3 + d * 2),
                                vy: Math.sin(angle) * (3 + d * 2),
                                radius: 8 - d * 2,
                                color: d === 0 ? '#00ffff' : d === 1 ? '#9370db' : '#ff00ff',
                                life: 30 + d * 10
                            });
                        }
                    }

                    // Damage all enemies in radius
                    for (const e of enemies) {
                        const dist = Math.hypot(e.x - player.x, e.y - player.y);
                        if (dist < radius) {
                            e.health -= damage;
                            e.stunned = now + 500;
                            if (e.health <= 0) {
                                score += e.soulValue * 10;
                                souls += e.soulValue;
                                playSound('kill');
                            }
                        }
                    }

                    // Store nova effect for drawing
                    player.novaEffect = { radius: radius, time: now };
                    break;
                }

                case 'battleRage': {
                    // Barbarian: Temporary damage and speed buff
                    const duration = classDef.abilityDuration * player.abilityDurationMult;
                    const damageBuff = classDef.abilityDamageBuff * player.abilityPower;
                    const speedBuff = classDef.abilitySpeedBuff * player.abilityPower;

                    playSound('bossSpawn');

                    player.rageActive = true;
                    player.rageDamageBonus = damageBuff;
                    player.rageSpeedBonus = speedBuff;
                    player.abilityActiveEnd = now + duration;

                    // Visual effect - red particles burst
                    for (let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        particles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * (2 + Math.random() * 3),
                            vy: Math.sin(angle) * (2 + Math.random() * 3),
                            radius: 6 + Math.random() * 4,
                            color: '#ff4444',
                            life: 40
                        });
                    }
                    break;
                }

                case 'shadowStep': {
                    // Ninja: Dash in movement direction with invincibility
                    const distance = classDef.abilityDistance * player.abilityPower;
                    const invincTime = classDef.abilityInvincibility * player.abilityDurationMult;
                    const trailDamage = classDef.abilityTrailDamage * player.abilityPower;

                    playSound('teleport');

                    // Determine dash direction from movement keys or mouse
                    let dx = 0, dy = 0;
                    if (keys['w'] || keys['arrowup']) dy -= 1;
                    if (keys['s'] || keys['arrowdown']) dy += 1;
                    if (keys['a'] || keys['arrowleft']) dx -= 1;
                    if (keys['d'] || keys['arrowright']) dx += 1;

                    // If no movement keys, dash toward mouse
                    if (dx === 0 && dy === 0) {
                        dx = mouseX - player.x;
                        dy = mouseY - player.y;
                    }

                    const len = Math.hypot(dx, dy);
                    if (len > 0) {
                        dx /= len;
                        dy /= len;
                    }

                    const startX = player.x;
                    const startY = player.y;

                    // Move player
                    player.x = Math.max(player.radius, Math.min(W - player.radius, player.x + dx * distance));
                    player.y = Math.max(player.radius, Math.min(H - player.radius, player.y + dy * distance));

                    // Create trail effect and damage enemies along path
                    const trailSteps = 10;
                    for (let i = 0; i <= trailSteps; i++) {
                        const t = i / trailSteps;
                        const tx = startX + (player.x - startX) * t;
                        const ty = startY + (player.y - startY) * t;

                        // Trail particles
                        for (let j = 0; j < 3; j++) {
                            particles.push({
                                x: tx + (Math.random() - 0.5) * 20,
                                y: ty + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 2,
                                vy: (Math.random() - 0.5) * 2,
                                radius: 5 + Math.random() * 5,
                                color: '#5f9f9f',
                                life: 20 + Math.random() * 20
                            });
                        }

                        // Damage enemies along trail
                        for (const e of enemies) {
                            const dist = Math.hypot(e.x - tx, e.y - ty);
                            if (dist < 40 && !e.trailHit) {
                                e.health -= trailDamage;
                                e.trailHit = true;
                                if (e.health <= 0) {
                                    score += e.soulValue * 10;
                                    souls += e.soulValue;
                                    playSound('kill');
                                }
                            }
                        }
                    }

                    // Reset trail hit flags
                    for (const e of enemies) {
                        e.trailHit = false;
                    }

                    // Grant invincibility
                    player.invincible = now + invincTime;
                    break;
                }

                case 'shieldWall': {
                    // Knight: Damage reduction and reflect
                    const duration = classDef.abilityDuration * player.abilityDurationMult;
                    const damageReduction = classDef.abilityDamageReduction * player.abilityPower;
                    const reflect = classDef.abilityReflect * player.abilityPower;

                    playSound('upgrade');

                    player.shieldActive = true;
                    player.shieldDamageReduction = damageReduction;
                    player.shieldReflect = reflect;
                    player.abilityActiveEnd = now + duration;

                    // Visual effect - golden shield particles
                    for (let i = 0; i < 16; i++) {
                        const angle = (i / 16) * Math.PI * 2;
                        particles.push({
                            x: player.x + Math.cos(angle) * 30,
                            y: player.y + Math.sin(angle) * 30,
                            vx: Math.cos(angle) * 0.5,
                            vy: Math.sin(angle) * 0.5,
                            radius: 6,
                            color: '#ffd700',
                            life: 30
                        });
                    }
                    break;
                }
            }

            // Set cooldown
            player.abilityCooldownEnd = now + cooldown;
        }

        function updateAbilities() {
            const now = Date.now();

            // Update Battle Rage
            if (player.rageActive && now >= player.abilityActiveEnd) {
                player.rageActive = false;
                player.rageDamageBonus = 0;
                player.rageSpeedBonus = 0;
            }

            // Update Shield Wall
            if (player.shieldActive && now >= player.abilityActiveEnd) {
                player.shieldActive = false;
                player.shieldDamageReduction = 0;
                player.shieldReflect = 0;
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];

                // Tracking
                if (b.tracking > 0 && enemies.length > 0) {
                    let closest = null;
                    let closestDist = Infinity;
                    for (const e of enemies) {
                        const dist = Math.hypot(e.x - b.x, e.y - b.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closest = e;
                        }
                    }
                    if (closest) {
                        const targetAngle = Math.atan2(closest.y - b.y, closest.x - b.x);
                        const currentAngle = Math.atan2(b.vy, b.vx);
                        let angleDiff = targetAngle - currentAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        const newAngle = currentAngle + angleDiff * b.tracking * 0.1;
                        const speed = Math.hypot(b.vx, b.vy);
                        b.vx = Math.cos(newAngle) * speed;
                        b.vy = Math.sin(newAngle) * speed;
                        b.angle = newAngle;
                    }
                }

                b.x += b.vx;
                b.y += b.vy;

                // Check if bullet exceeded its range
                const travelDist = Math.hypot(b.x - b.startX, b.y - b.startY);
                if (travelDist > b.maxRange) {
                    // Fade out particle
                    particles.push({
                        x: b.x,
                        y: b.y,
                        vx: 0,
                        vy: 0,
                        radius: b.radius * 0.8,
                        color: classDefinitions[player.class]?.color || '#888',
                        life: 10
                    });
                    bullets.splice(i, 1);
                    continue;
                }

                // Ricochet off world boundaries
                let bounced = false;
                if (b.x < 0 || b.x > WORLD_WIDTH) {
                    if (b.bounces === undefined) b.bounces = 0;
                    if (b.bounces < player.ricochetCount) {
                        b.vx = -b.vx;
                        b.x = b.x < 0 ? 0 : WORLD_WIDTH;
                        b.bounces++;
                        bounced = true;
                        // Ricochet particle effect
                        for (let p = 0; p < 4; p++) {
                            particles.push({
                                x: b.x, y: b.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 15, color: '#88ff88', radius: 3
                            });
                        }
                    }
                }
                if (b.y < 0 || b.y > WORLD_HEIGHT) {
                    if (b.bounces === undefined) b.bounces = 0;
                    if (b.bounces < player.ricochetCount) {
                        b.vy = -b.vy;
                        b.y = b.y < 0 ? 0 : WORLD_HEIGHT;
                        b.bounces++;
                        bounced = true;
                        for (let p = 0; p < 4; p++) {
                            particles.push({
                                x: b.x, y: b.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 15, color: '#88ff88', radius: 3
                            });
                        }
                    }
                }

                // Remove bullets that exit world bounds
                if (!bounced && (b.x < -50 || b.x > WORLD_WIDTH + 50 || b.y < -50 || b.y > WORLD_HEIGHT + 50)) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Also check if bullets can hit hazards
                for (let h = hazards.length - 1; h >= 0; h--) {
                    const hazard = hazards[h];
                    const dist = Math.hypot(hazard.x - b.x, hazard.y - b.y);
                    if (dist < hazard.radius + b.radius) {
                        hazard.health -= b.damage;
                        b.pierce--;
                        if (b.pierce <= 0) {
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    const dist = Math.hypot(e.x - b.x, e.y - b.y);

                    if (e.special === 'phase' && e.phaseTimer > 0) continue;

                    if (dist < e.radius + b.radius) {
                        const now = Date.now();

                        // Combo system
                        if (now - player.lastHitTime < 1500) {
                            player.comboCount = Math.min(player.comboMax, player.comboCount + 1);
                        } else {
                            player.comboCount = 1;
                        }
                        player.lastHitTime = now;

                        // Calculate final damage with modifiers
                        let finalDamage = b.damage;

                        // Combo bonus
                        if (player.comboBonus > 0) {
                            finalDamage *= (1 + player.comboBonus * player.comboCount);
                        }

                        // Execute damage (bonus damage to enemies below 30% HP)
                        if (player.executeDamage > 0 && e.health < e.maxHealth * 0.3) {
                            finalDamage *= (1 + player.executeDamage);
                            // Execute visual
                            particles.push({
                                x: e.x, y: e.y - e.radius,
                                vx: 0, vy: -1,
                                life: 25, color: '#ff0000', radius: 8
                            });
                        }

                        e.health -= finalDamage;
                        playSound('hit');

                        // Chain Lightning on crit
                        if (b.isCrit && player.critChainCount > 0) {
                            let chainTargets = [];
                            for (const e2 of enemies) {
                                if (e2 !== e && Math.hypot(e2.x - e.x, e2.y - e.y) < 150) {
                                    chainTargets.push(e2);
                                }
                            }
                            chainTargets.sort((a, b) => Math.hypot(a.x - e.x, a.y - e.y) - Math.hypot(b.x - e.x, b.y - e.y));
                            let lastX = e.x, lastY = e.y;
                            for (let c = 0; c < Math.min(player.critChainCount, chainTargets.length); c++) {
                                const target = chainTargets[c];
                                const chainDmg = finalDamage * player.critChainDamage;
                                target.health -= chainDmg;
                                // Chain lightning visual
                                for (let p = 0; p < 8; p++) {
                                    const t = p / 8;
                                    particles.push({
                                        x: lastX + (target.x - lastX) * t + (Math.random() - 0.5) * 15,
                                        y: lastY + (target.y - lastY) * t + (Math.random() - 0.5) * 15,
                                        vx: (Math.random() - 0.5) * 2,
                                        vy: (Math.random() - 0.5) * 2,
                                        life: 15, color: '#00ffff', radius: 4
                                    });
                                }
                                lastX = target.x;
                                lastY = target.y;
                                if (target.health <= 0 && !target.isDead) {
                                    target.isDead = true;
                                    score += target.soulValue * 10;
                                    spawnSoulOrb(target.x, target.y, target.soulValue);
                                    enemiesRemaining--;
                                    playSound('kill');
                                }
                            }
                        }

                        if (b.stun) {
                            e.stunned = Date.now() + player.stunDuration;
                        }

                        if (b.explosive) {
                            createExplosion(b.x, b.y);
                            playSound('explosion');
                            for (const e2 of enemies) {
                                if (e2 !== e && Math.hypot(e2.x - b.x, e2.y - b.y) < player.explosiveRadius) {
                                    e2.health -= finalDamage * 0.5;
                                }
                            }
                        }

                        if (player.vampiric > 0) {
                            player.health = Math.min(player.maxHealth, player.health + finalDamage * player.vampiric);
                        }

                        for (let p = 0; p < 3; p++) {
                            particles.push({
                                x: b.x,
                                y: b.y,
                                vx: (Math.random() - 0.5) * 5,
                                vy: (Math.random() - 0.5) * 5,
                                life: 20,
                                color: b.isCrit ? '#ffff00' : '#ff6600',
                                radius: b.isCrit ? 4 : 2
                            });
                        }

                        if (e.health <= 0 && !e.isDead) {
                            e.isDead = true;
                            score += e.soulValue * 10;
                            spawnSoulOrb(e.x, e.y, e.soulValue);
                            enemiesRemaining--;
                            playSound('kill');

                            for (let p = 0; p < 15; p++) {
                                particles.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: (Math.random() - 0.5) * 8,
                                    vy: (Math.random() - 0.5) * 8,
                                    life: 40,
                                    color: e.color,
                                    radius: 5
                                });
                            }

                            enemies.splice(j, 1);
                        }

                        b.pierce--;
                        if (b.pierce <= 0) {
                            bullets.splice(i, 1);
                        }
                        break;
                    }
                }
            }
        }

        function spawnSoulOrb(x, y, value) {
            soulOrbs.push({
                x, y, value,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3 - 2,
                life: 300 // 5 seconds at 60fps
            });
        }

        function updateSoulOrbs() {
            for (let i = soulOrbs.length - 1; i >= 0; i--) {
                const orb = soulOrbs[i];

                // Apply velocity with friction
                orb.x += orb.vx;
                orb.y += orb.vy;
                orb.vx *= 0.95;
                orb.vy *= 0.95;
                orb.vy += 0.1; // Gravity

                // Bounce on floor
                if (orb.y > H - 10) {
                    orb.y = H - 10;
                    orb.vy = -orb.vy * 0.5;
                }

                // Soul magnet - attract to player
                if (player.soulMagnetRadius > 0) {
                    const dist = Math.hypot(player.x - orb.x, player.y - orb.y);
                    if (dist < player.soulMagnetRadius) {
                        const pullStrength = (1 - dist / player.soulMagnetRadius) * 0.3;
                        orb.vx += (player.x - orb.x) * pullStrength * 0.1;
                        orb.vy += (player.y - orb.y) * pullStrength * 0.1;
                    }
                }

                // Collect orb
                const collectDist = Math.hypot(player.x - orb.x, player.y - orb.y);
                if (collectDist < player.radius + 15) {
                    souls += orb.value;
                    playSound('upgrade');
                    // Collection particles
                    for (let p = 0; p < 5; p++) {
                        particles.push({
                            x: orb.x, y: orb.y,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 20, color: '#ffd700', radius: 4
                        });
                    }
                    soulOrbs.splice(i, 1);
                    continue;
                }

                orb.life--;
                if (orb.life <= 0) {
                    // Auto-collect when expiring
                    souls += orb.value;
                    soulOrbs.splice(i, 1);
                }
            }
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                particles.push({
                    x,
                    y,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    life: 25,
                    color: '#ff4400',
                    radius: 6
                });
            }
        }

        function updateEnemies() {
            const now = Date.now();

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];

                if (e.stunned > now) continue;

                // Special behaviors
                if (e.special === 'teleport' && e.teleportCooldown < now) {
                    if (Math.random() < 0.01) {
                        const newPos = getSpawnPosition();
                        e.x = player.x + (Math.random() - 0.5) * 250;
                        e.y = player.y + (Math.random() - 0.5) * 250;
                        e.x = Math.max(50, Math.min(W - 50, e.x));
                        e.y = Math.max(50, Math.min(H - 50, e.y));
                        e.teleportCooldown = now + 2000;
                        playSound('teleport');
                        for (let p = 0; p < 10; p++) {
                            particles.push({
                                x: e.x, y: e.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 20,
                                color: '#8b008b',
                                radius: 3
                            });
                        }
                    }
                }

                if (e.special === 'phase') {
                    if (e.phaseTimer <= 0 && Math.random() < 0.005) {
                        e.phaseTimer = 60;
                    }
                    if (e.phaseTimer > 0) e.phaseTimer--;
                }

                if (e.special === 'summon' && e.summonCooldown < now) {
                    if (Math.random() < 0.005) {
                        const template = enemyTypes.skeleton;
                        const pos = { x: e.x + (Math.random() - 0.5) * 60, y: e.y + (Math.random() - 0.5) * 60 };
                        enemies.push({
                            x: pos.x,
                            y: pos.y,
                            type: 'skeleton',
                            ...template,
                            health: template.health,
                            maxHealth: template.health,
                            stunned: 0,
                            phaseTimer: 0,
                            teleportCooldown: 0,
                            summonCooldown: 0
                        });
                        enemiesRemaining++;
                        e.summonCooldown = now + 3000;
                    }
                }

                if (e.special === 'regen') {
                    e.regenTimer = (e.regenTimer || 0) + 1;
                    if (e.regenTimer >= 30) {
                        e.health = Math.min(e.maxHealth, e.health + e.maxHealth * 0.02);
                        e.regenTimer = 0;
                    }
                }

                // Move toward player
                const angle = Math.atan2(player.y - e.y, player.x - e.x);
                e.x += Math.cos(angle) * e.speed;
                e.y += Math.sin(angle) * e.speed;

                // Collision with player
                const dist = Math.hypot(player.x - e.x, player.y - e.y);
                if (dist < player.radius + e.radius && player.invincible < now) {
                    // Apply damage reduction (passive + shield wall)
                    const totalDamageReduction = Math.min(0.95, player.damageReduction + (player.shieldActive ? player.shieldDamageReduction : 0));
                    let damage = e.damage * (1 - totalDamageReduction);
                    player.health -= damage;
                    player.invincible = now + 500;
                    playSound('playerHit');

                    // Shield Wall reflect damage
                    if (player.shieldActive && player.shieldReflect > 0) {
                        const reflectDamage = e.damage * player.shieldReflect;
                        e.health -= reflectDamage;
                        // Visual feedback for reflect
                        for (let p = 0; p < 5; p++) {
                            particles.push({
                                x: e.x,
                                y: e.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 20,
                                color: '#ffd700',
                                radius: 5
                            });
                        }
                        if (e.health <= 0) {
                            score += e.soulValue * 10;
                            souls += e.soulValue;
                            playSound('kill');
                        }
                    }

                    const knockAngle = Math.atan2(player.y - e.y, player.x - e.x);
                    player.x += Math.cos(knockAngle) * 30;
                    player.y += Math.sin(knockAngle) * 30;

                    for (let p = 0; p < 10; p++) {
                        particles.push({
                            x: player.x,
                            y: player.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            life: 30,
                            color: player.shieldActive ? '#ffd700' : '#ff0000',
                            radius: 4
                        });
                    }
                }
            }
        }

        function updatePlayer() {
            // Update world mouse coordinates
            worldMouseX = mouseX + camera.x;
            worldMouseY = mouseY + camera.y;

            // Life regen
            if (player.lifeRegen > 0) {
                player.health = Math.min(player.maxHealth, player.health + player.lifeRegen / 60);
            }

            // Movement with temp speed bonus
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy -= 1;
            if (keys['s'] || keys['arrowdown']) dy += 1;
            if (keys['a'] || keys['arrowleft']) dx -= 1;
            if (keys['d'] || keys['arrowright']) dx += 1;

            if (dx !== 0 || dy !== 0) {
                const len = Math.hypot(dx, dy);
                const speedMult = 1 + (player.rageActive ? player.rageSpeedBonus : 0) + (player.tempSpeedBonus || 0);
                player.x += (dx / len) * player.speed * speedMult;
                player.y += (dy / len) * player.speed * speedMult;
            }

            // Clamp to world boundaries
            const effectiveRadius = player.radius * (1 + (player.tempSizeBonus || 0));
            player.x = Math.max(effectiveRadius, Math.min(WORLD_WIDTH - effectiveRadius, player.x));
            player.y = Math.max(effectiveRadius, Math.min(WORLD_HEIGHT - effectiveRadius, player.y));

            // Update camera
            updateCamera();

            if (mouseDown) {
                shoot();
            }

            if (player.health <= 0) {
                gameState = 'gameover';
                playSound('gameOver');
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('finalScore').textContent = `Final Score: ${score}`;
                document.getElementById('finalWave').textContent = `Reached Wave: ${wave}`;
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawPlayer() {
            ctx.save();

            if (player.invincible > Date.now() && Math.floor(Date.now() / 50) % 2) {
                ctx.globalAlpha = 0.5;
            }

            const classDef = classDefinitions[player.class];

            // Draw based on class
            switch(player.class) {
                case 'mage':
                    // Robe body
                    ctx.fillStyle = classDef.secondaryColor;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Hood
                    ctx.fillStyle = classDef.color;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y - 5, player.radius * 0.7, Math.PI, 0);
                    ctx.fill();
                    // Staff glow
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(player.x + 15, player.y - 15, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ffff';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;

                case 'barbarian':
                    // Muscular body
                    ctx.fillStyle = '#d4a574';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // War paint
                    ctx.strokeStyle = classDef.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(player.x - 10, player.y - 5);
                    ctx.lineTo(player.x - 5, player.y);
                    ctx.lineTo(player.x - 10, player.y + 5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(player.x + 10, player.y - 5);
                    ctx.lineTo(player.x + 5, player.y);
                    ctx.lineTo(player.x + 10, player.y + 5);
                    ctx.stroke();
                    // Mohawk
                    ctx.fillStyle = classDef.secondaryColor;
                    for (let i = -2; i <= 2; i++) {
                        ctx.fillRect(player.x + i * 4 - 2, player.y - player.radius - 8, 4, 10);
                    }
                    break;

                case 'ninja':
                    // Body
                    ctx.fillStyle = classDef.secondaryColor;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Mask
                    ctx.fillStyle = classDef.color;
                    ctx.fillRect(player.x - 12, player.y - 8, 24, 8);
                    // Eyes
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(player.x - 8, player.y - 6, 5, 3);
                    ctx.fillRect(player.x + 3, player.y - 6, 5, 3);
                    // Headband tails
                    ctx.strokeStyle = classDef.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(player.x + 12, player.y - 5);
                    ctx.quadraticCurveTo(player.x + 25, player.y - 10, player.x + 20, player.y + 5);
                    ctx.stroke();
                    break;

                case 'knight':
                    // Armor body
                    ctx.fillStyle = '#888';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Helmet
                    ctx.fillStyle = classDef.secondaryColor;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y - 5, player.radius * 0.8, Math.PI, 0);
                    ctx.fill();
                    // Visor slit
                    ctx.fillStyle = '#222';
                    ctx.fillRect(player.x - 10, player.y - 8, 20, 4);
                    // Plume
                    ctx.fillStyle = classDef.color;
                    ctx.beginPath();
                    ctx.ellipse(player.x, player.y - player.radius - 5, 4, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }

            // Eyes looking at mouse (for mage and barbarian) - use world coordinates
            if (player.class === 'mage' || player.class === 'barbarian') {
                const eyeAngle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);
                const eyeOffsetX = Math.cos(eyeAngle) * 2;
                const eyeOffsetY = Math.sin(eyeAngle) * 2;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(player.x - 5, player.y - 3, 3, 0, Math.PI * 2);
                ctx.arc(player.x + 5, player.y - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(player.x - 5 + eyeOffsetX, player.y - 3 + eyeOffsetY, 1.5, 0, Math.PI * 2);
                ctx.arc(player.x + 5 + eyeOffsetX, player.y - 3 + eyeOffsetY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawEnemy(e) {
            ctx.save();
            ctx.translate(e.x, e.y);

            // Calculate angle toward player for facing direction
            const angle = Math.atan2(player.y - e.y, player.x - e.x);

            if (e.special === 'phase' && e.phaseTimer > 0) {
                ctx.globalAlpha = 0.3;
            }

            const isStunned = e.stunned > Date.now();
            const r = e.radius;

            switch(e.type) {
                case 'goblin':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#5a8a32';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r * 0.8, r, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Big ears
                    ctx.fillStyle = isStunned ? '#99e' : '#4a7a22';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.9, -r * 0.3, r * 0.4, r * 0.6, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(r * 0.9, -r * 0.3, r * 0.4, r * 0.6, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.2, r * 0.2, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.2, r * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.2, r * 0.1, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.2, r * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    // Big nose
                    ctx.fillStyle = isStunned ? '#88c' : '#3a6a12';
                    ctx.beginPath();
                    ctx.arc(0, r * 0.1, r * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    // Mouth
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, r * 0.4, r * 0.3, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                    break;

                case 'skeleton':
                    // Skull
                    ctx.fillStyle = isStunned ? '#aaf' : '#e8e8d8';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.1, r * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    // Jaw
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.4, r * 0.5, r * 0.35, 0, 0, Math.PI);
                    ctx.fill();
                    // Eye sockets
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.25, -r * 0.2, r * 0.2, r * 0.25, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.25, -r * 0.2, r * 0.2, r * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Glowing eyes
                    ctx.fillStyle = '#f44';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.2, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.2, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose hole
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(0, r * 0.05);
                    ctx.lineTo(-r * 0.1, r * 0.2);
                    ctx.lineTo(r * 0.1, r * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    // Teeth
                    ctx.fillStyle = isStunned ? '#aaf' : '#e8e8d8';
                    for (let i = -2; i <= 2; i++) {
                        ctx.fillRect(i * r * 0.15 - r * 0.05, r * 0.25, r * 0.1, r * 0.15);
                    }
                    break;

                case 'orc':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#4a6a2a';
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Brow ridge
                    ctx.fillStyle = isStunned ? '#99e' : '#3a5a1a';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.4, r * 0.8, r * 0.3, 0, Math.PI, 0);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(-r * 0.3, -r * 0.15, r * 0.15, 0, Math.PI * 2);
                    ctx.arc(r * 0.3, -r * 0.15, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.3, -r * 0.15, r * 0.07, 0, Math.PI * 2);
                    ctx.arc(r * 0.3, -r * 0.15, r * 0.07, 0, Math.PI * 2);
                    ctx.fill();
                    // Tusks
                    ctx.fillStyle = '#fffff0';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.4, r * 0.2);
                    ctx.lineTo(-r * 0.5, -r * 0.2);
                    ctx.lineTo(-r * 0.25, r * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.4, r * 0.2);
                    ctx.lineTo(r * 0.5, -r * 0.2);
                    ctx.lineTo(r * 0.25, r * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    // Nose
                    ctx.fillStyle = isStunned ? '#88c' : '#2a4a0a';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.15, r * 0.2, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'harpy':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#8b668b';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r * 0.6, r * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Wings
                    ctx.fillStyle = isStunned ? '#99e' : '#6b466b';
                    const wingFlap = Math.sin(Date.now() / 80) * 0.3;
                    ctx.save();
                    ctx.rotate(-0.5 + wingFlap);
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.8, 0, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    ctx.save();
                    ctx.rotate(0.5 - wingFlap);
                    ctx.beginPath();
                    ctx.ellipse(r * 0.8, 0, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    // Face
                    ctx.fillStyle = '#dbb';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(-r * 0.15, -r * 0.35, r * 0.1, 0, Math.PI * 2);
                    ctx.arc(r * 0.15, -r * 0.35, r * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    // Beak
                    ctx.fillStyle = '#fa0';
                    ctx.beginPath();
                    ctx.moveTo(0, -r * 0.2);
                    ctx.lineTo(-r * 0.1, -r * 0.05);
                    ctx.lineTo(r * 0.1, -r * 0.05);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case 'minotaur':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#6b4423';
                    ctx.beginPath();
                    ctx.arc(0, r * 0.1, r * 0.85, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.3, r * 0.6, r * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Horns
                    ctx.fillStyle = isStunned ? '#ddd' : '#fffff0';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.5, -r * 0.5);
                    ctx.quadraticCurveTo(-r * 0.9, -r * 0.9, -r * 0.7, -r * 1.1);
                    ctx.quadraticCurveTo(-r * 0.5, -r * 0.8, -r * 0.3, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.5, -r * 0.5);
                    ctx.quadraticCurveTo(r * 0.9, -r * 0.9, r * 0.7, -r * 1.1);
                    ctx.quadraticCurveTo(r * 0.5, -r * 0.8, r * 0.3, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    // Snout
                    ctx.fillStyle = isStunned ? '#99e' : '#5b3413';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.1, r * 0.35, r * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Nostrils
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(-r * 0.12, -r * 0.05, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.12, -r * 0.05, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.4, r * 0.12, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.4, r * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose ring
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, r * 0.05, r * 0.15, 0.3, Math.PI - 0.3);
                    ctx.stroke();
                    break;

                case 'wraith':
                    // Ghostly body
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                    gradient.addColorStop(0, isStunned ? 'rgba(150,150,255,0.8)' : 'rgba(100,100,150,0.8)');
                    gradient.addColorStop(1, 'rgba(50,50,80,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Tattered cloak shape
                    ctx.fillStyle = isStunned ? 'rgba(150,150,255,0.6)' : 'rgba(60,60,100,0.7)';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.6, -r * 0.5);
                    ctx.quadraticCurveTo(0, -r * 0.8, r * 0.6, -r * 0.5);
                    ctx.lineTo(r * 0.8, r * 0.8);
                    ctx.quadraticCurveTo(r * 0.4, r * 0.6, 0, r);
                    ctx.quadraticCurveTo(-r * 0.4, r * 0.6, -r * 0.8, r * 0.8);
                    ctx.closePath();
                    ctx.fill();
                    // Glowing eyes
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0ff';
                    ctx.fillStyle = '#0ff';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.2, r * 0.12, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.2, r * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;

                case 'basilisk':
                    // Snake body
                    ctx.fillStyle = isStunned ? '#aaf' : '#2d5a27';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r, r * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Scales pattern
                    ctx.fillStyle = isStunned ? '#99e' : '#1d4a17';
                    for (let i = -2; i <= 2; i++) {
                        for (let j = -1; j <= 1; j++) {
                            ctx.beginPath();
                            ctx.arc(i * r * 0.3, j * r * 0.25, r * 0.12, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    // Head
                    ctx.fillStyle = isStunned ? '#aaf' : '#2d5a27';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.4, r * 0.5, r * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Crown/crest
                    ctx.fillStyle = '#f44';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.2, -r * 0.7);
                    ctx.lineTo(0, -r * 1);
                    ctx.lineTo(r * 0.2, -r * 0.7);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.2, -r * 0.45, r * 0.12, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.2, -r * 0.45, r * 0.12, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.2, -r * 0.45, r * 0.04, r * 0.1, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.2, -r * 0.45, r * 0.04, r * 0.1, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Tongue
                    ctx.strokeStyle = '#f44';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -r * 0.2);
                    ctx.lineTo(0, -r * 0.05);
                    ctx.lineTo(-r * 0.1, r * 0.1);
                    ctx.moveTo(0, -r * 0.05);
                    ctx.lineTo(r * 0.1, r * 0.1);
                    ctx.stroke();
                    break;

                case 'vampire':
                    // Cape
                    ctx.fillStyle = isStunned ? '#66a' : '#2a0a2a';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.3, -r * 0.5);
                    ctx.quadraticCurveTo(-r * 1.1, 0, -r * 0.9, r * 0.9);
                    ctx.lineTo(0, r * 0.6);
                    ctx.lineTo(r * 0.9, r * 0.9);
                    ctx.quadraticCurveTo(r * 1.1, 0, r * 0.3, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#4a0a2a';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r * 0.5, r * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Face
                    ctx.fillStyle = '#ddd';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.25, r * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Hair
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.35, r * 0.4, Math.PI, 0);
                    ctx.fill();
                    // Widow's peak
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.2, -r * 0.5);
                    ctx.lineTo(0, -r * 0.25);
                    ctx.lineTo(r * 0.2, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(-r * 0.15, -r * 0.3, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.15, -r * 0.3, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Fangs
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.1, -r * 0.05);
                    ctx.lineTo(-r * 0.05, r * 0.15);
                    ctx.lineTo(0, -r * 0.05);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(0, -r * 0.05);
                    ctx.lineTo(r * 0.05, r * 0.15);
                    ctx.lineTo(r * 0.1, -r * 0.05);
                    ctx.fill();
                    break;

                case 'lich':
                    // Robe
                    ctx.fillStyle = isStunned ? '#66a' : '#2a1a4a';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.5, -r * 0.3);
                    ctx.lineTo(-r * 0.8, r);
                    ctx.lineTo(r * 0.8, r);
                    ctx.lineTo(r * 0.5, -r * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    // Skull face
                    ctx.fillStyle = isStunned ? '#ccf' : '#c0c0a0';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.2, r * 0.45, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye sockets with glow
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.18, -r * 0.25, r * 0.15, 0, Math.PI * 2);
                    ctx.arc(r * 0.18, -r * 0.25, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#a0f';
                    ctx.fillStyle = '#a0f';
                    ctx.beginPath();
                    ctx.arc(-r * 0.18, -r * 0.25, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.18, -r * 0.25, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Crown
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.35, -r * 0.55);
                    ctx.lineTo(-r * 0.25, -r * 0.85);
                    ctx.lineTo(-r * 0.1, -r * 0.6);
                    ctx.lineTo(0, -r * 0.9);
                    ctx.lineTo(r * 0.1, -r * 0.6);
                    ctx.lineTo(r * 0.25, -r * 0.85);
                    ctx.lineTo(r * 0.35, -r * 0.55);
                    ctx.closePath();
                    ctx.fill();
                    // Staff
                    ctx.strokeStyle = '#4a3a2a';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(r * 0.6, -r * 0.4);
                    ctx.lineTo(r * 0.6, r * 0.8);
                    ctx.stroke();
                    ctx.fillStyle = '#a0f';
                    ctx.beginPath();
                    ctx.arc(r * 0.6, -r * 0.5, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'cyclops':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#7a6a5a';
                    ctx.beginPath();
                    ctx.arc(0, r * 0.1, r * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    // One big eye
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#840';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    // Brow
                    ctx.fillStyle = isStunned ? '#99e' : '#5a4a3a';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.55, r * 0.5, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Mouth
                    ctx.fillStyle = '#3a2a1a';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.2, r * 0.3, r * 0.15, 0, 0, Math.PI);
                    ctx.fill();
                    // Teeth
                    ctx.fillStyle = '#ff9';
                    for (let i = -2; i <= 2; i++) {
                        ctx.fillRect(i * r * 0.12 - r * 0.04, r * 0.1, r * 0.08, r * 0.12);
                    }
                    break;

                case 'hydra':
                    // Main body
                    ctx.fillStyle = isStunned ? '#aaf' : '#2a6a4a';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.2, r * 0.7, r * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Multiple heads (3)
                    const headPositions = [
                        {x: -r * 0.5, y: -r * 0.5, rot: -0.3},
                        {x: 0, y: -r * 0.7, rot: 0},
                        {x: r * 0.5, y: -r * 0.5, rot: 0.3}
                    ];
                    for (const head of headPositions) {
                        ctx.save();
                        ctx.translate(head.x, head.y);
                        ctx.rotate(head.rot);
                        // Neck
                        ctx.fillStyle = isStunned ? '#aaf' : '#2a6a4a';
                        ctx.beginPath();
                        ctx.ellipse(0, r * 0.2, r * 0.15, r * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Head
                        ctx.beginPath();
                        ctx.ellipse(0, -r * 0.1, r * 0.25, r * 0.2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Eyes
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(-r * 0.1, -r * 0.15, r * 0.06, 0, Math.PI * 2);
                        ctx.arc(r * 0.1, -r * 0.15, r * 0.06, 0, Math.PI * 2);
                        ctx.fill();
                        // Teeth
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.moveTo(-r * 0.1, 0);
                        ctx.lineTo(-r * 0.05, r * 0.1);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(r * 0.05, r * 0.1);
                        ctx.lineTo(r * 0.1, 0);
                        ctx.fill();
                        ctx.restore();
                    }
                    break;

                case 'dragon':
                    // Wings
                    ctx.fillStyle = isStunned ? '#88a' : '#6a0000';
                    const wingFlap2 = Math.sin(Date.now() / 100) * 0.2;
                    ctx.save();
                    ctx.rotate(-0.4 + wingFlap2);
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.3, 0);
                    ctx.quadraticCurveTo(-r * 1.2, -r * 0.5, -r * 1.3, r * 0.2);
                    ctx.quadraticCurveTo(-r * 0.8, r * 0.1, -r * 0.3, 0);
                    ctx.fill();
                    ctx.restore();
                    ctx.save();
                    ctx.rotate(0.4 - wingFlap2);
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, 0);
                    ctx.quadraticCurveTo(r * 1.2, -r * 0.5, r * 1.3, r * 0.2);
                    ctx.quadraticCurveTo(r * 0.8, r * 0.1, r * 0.3, 0);
                    ctx.fill();
                    ctx.restore();
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#8b0000';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.1, r * 0.6, r * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.5, r * 0.45, r * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Horns
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.35, -r * 0.7);
                    ctx.lineTo(-r * 0.5, -r * 1.1);
                    ctx.lineTo(-r * 0.2, -r * 0.75);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.35, -r * 0.7);
                    ctx.lineTo(r * 0.5, -r * 1.1);
                    ctx.lineTo(r * 0.2, -r * 0.75);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#ff0';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#f80';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.18, -r * 0.55, r * 0.12, r * 0.08, -0.2, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.18, -r * 0.55, r * 0.12, r * 0.08, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.18, -r * 0.55, r * 0.04, r * 0.06, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.18, -r * 0.55, r * 0.04, r * 0.06, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Snout
                    ctx.fillStyle = isStunned ? '#99e' : '#7a0000';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.3, r * 0.25, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Nostrils with smoke
                    ctx.fillStyle = '#f80';
                    ctx.beginPath();
                    ctx.arc(-r * 0.1, -r * 0.28, r * 0.05, 0, Math.PI * 2);
                    ctx.arc(r * 0.1, -r * 0.28, r * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    // Spines
                    ctx.fillStyle = '#440000';
                    for (let i = 0; i < 5; i++) {
                        const spineY = -r * 0.7 + i * r * 0.35;
                        const spineSize = r * 0.15 - i * r * 0.02;
                        ctx.beginPath();
                        ctx.moveTo(0, spineY);
                        ctx.lineTo(-spineSize, spineY + spineSize);
                        ctx.lineTo(spineSize, spineY + spineSize);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;

                case 'beholder':
                    // Main eye body
                    ctx.fillStyle = isStunned ? '#aaf' : '#8b4513';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyestalks (4 on top)
                    ctx.strokeStyle = isStunned ? '#99e' : '#6b3503';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 4; i++) {
                        const stalkAngle = -Math.PI * 0.8 + (i * Math.PI * 0.4);
                        const wobble = Math.sin(Date.now() / 150 + i) * 0.1;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(stalkAngle) * r * 0.5, Math.sin(stalkAngle) * r * 0.5);
                        ctx.quadraticCurveTo(
                            Math.cos(stalkAngle + wobble) * r * 0.8,
                            Math.sin(stalkAngle + wobble) * r * 0.8 - r * 0.2,
                            Math.cos(stalkAngle) * r * 1.1,
                            Math.sin(stalkAngle) * r * 1.1
                        );
                        ctx.stroke();
                        // Mini eye at end
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(Math.cos(stalkAngle) * r * 1.1, Math.sin(stalkAngle) * r * 1.1, r * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(Math.cos(stalkAngle) * r * 1.1, Math.sin(stalkAngle) * r * 1.1, r * 0.05, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Central eye
                    ctx.fillStyle = '#fffff0';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#8b0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye glow
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#f00';
                    ctx.fillStyle = '#f44';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Mouth with teeth
                    ctx.fillStyle = '#3a1a03';
                    ctx.beginPath();
                    ctx.arc(0, r * 0.4, r * 0.35, 0.2, Math.PI - 0.2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    for (let i = -3; i <= 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * r * 0.08, r * 0.35);
                        ctx.lineTo(i * r * 0.08 - r * 0.03, r * 0.55);
                        ctx.lineTo(i * r * 0.08 + r * 0.03, r * 0.55);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;

                case 'golem':
                    // Rocky body
                    ctx.fillStyle = isStunned ? '#aaf' : '#696969';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.7, -r * 0.8);
                    ctx.lineTo(-r * 0.9, 0);
                    ctx.lineTo(-r * 0.7, r * 0.9);
                    ctx.lineTo(r * 0.7, r * 0.9);
                    ctx.lineTo(r * 0.9, 0);
                    ctx.lineTo(r * 0.7, -r * 0.8);
                    ctx.closePath();
                    ctx.fill();
                    // Cracks/texture
                    ctx.strokeStyle = isStunned ? '#88c' : '#4a4a4a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.4, -r * 0.6);
                    ctx.lineTo(-r * 0.2, r * 0.2);
                    ctx.lineTo(-r * 0.5, r * 0.7);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, -r * 0.5);
                    ctx.lineTo(r * 0.1, 0);
                    ctx.lineTo(r * 0.4, r * 0.5);
                    ctx.stroke();
                    // Glowing runes
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#0af';
                    ctx.strokeStyle = '#0af';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.2, -r * 0.1);
                    ctx.lineTo(r * 0.2, -r * 0.1);
                    ctx.moveTo(0, -r * 0.25);
                    ctx.lineTo(0, r * 0.15);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    // Eyes (glowing blue)
                    ctx.fillStyle = '#0af';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0af';
                    ctx.beginPath();
                    ctx.arc(-r * 0.25, -r * 0.4, r * 0.12, 0, Math.PI * 2);
                    ctx.arc(r * 0.25, -r * 0.4, r * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;

                case 'banshee':
                    // Ethereal glow
                    const bansheeGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                    bansheeGrad.addColorStop(0, isStunned ? 'rgba(150,150,255,0.9)' : 'rgba(200,200,255,0.9)');
                    bansheeGrad.addColorStop(0.5, isStunned ? 'rgba(100,100,200,0.5)' : 'rgba(150,150,200,0.5)');
                    bansheeGrad.addColorStop(1, 'rgba(100,100,150,0)');
                    ctx.fillStyle = bansheeGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Flowing form
                    ctx.fillStyle = isStunned ? 'rgba(150,150,255,0.7)' : 'rgba(220,220,255,0.7)';
                    ctx.beginPath();
                    ctx.moveTo(0, -r * 0.8);
                    ctx.quadraticCurveTo(-r * 0.5, -r * 0.4, -r * 0.6, r * 0.2);
                    ctx.quadraticCurveTo(-r * 0.4, r * 0.8, 0, r);
                    ctx.quadraticCurveTo(r * 0.4, r * 0.8, r * 0.6, r * 0.2);
                    ctx.quadraticCurveTo(r * 0.5, -r * 0.4, 0, -r * 0.8);
                    ctx.fill();
                    // Face
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    // Empty eye sockets
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.12, -r * 0.35, r * 0.1, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.12, -r * 0.35, r * 0.1, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Screaming mouth
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.05, r * 0.15, r * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Flowing hair
                    ctx.strokeStyle = isStunned ? 'rgba(150,150,255,0.6)' : 'rgba(200,200,255,0.6)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 5; i++) {
                        const hairWave = Math.sin(Date.now() / 100 + i) * r * 0.1;
                        ctx.beginPath();
                        ctx.moveTo(-r * 0.3 + i * r * 0.15, -r * 0.5);
                        ctx.quadraticCurveTo(-r * 0.3 + i * r * 0.15 + hairWave, -r * 0.9, -r * 0.4 + i * r * 0.2, -r * 1.1);
                        ctx.stroke();
                    }
                    break;

                case 'werewolf':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#4a4a4a';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.1, r * 0.7, r * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Fur texture
                    ctx.strokeStyle = isStunned ? '#88c' : '#3a3a3a';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 12; i++) {
                        const fAngle = (i / 12) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(fAngle) * r * 0.5, Math.sin(fAngle) * r * 0.5 + r * 0.1);
                        ctx.lineTo(Math.cos(fAngle) * r * 0.75, Math.sin(fAngle) * r * 0.85 + r * 0.1);
                        ctx.stroke();
                    }
                    // Snout
                    ctx.fillStyle = isStunned ? '#99e' : '#5a5a5a';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.1, r * 0.4, r * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = isStunned ? '#aaf' : '#2a2a2a';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.05, r * 0.25, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.15, r * 0.12, r * 0.08, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes (yellow, feral)
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.2, -r * 0.35, r * 0.12, r * 0.08, -0.2, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.2, -r * 0.35, r * 0.12, r * 0.08, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.2, -r * 0.35, r * 0.04, 0, Math.PI * 2);
                    ctx.arc(r * 0.2, -r * 0.35, r * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    // Ears
                    ctx.fillStyle = isStunned ? '#aaf' : '#4a4a4a';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.4, -r * 0.5);
                    ctx.lineTo(-r * 0.55, -r * 0.95);
                    ctx.lineTo(-r * 0.2, -r * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.4, -r * 0.5);
                    ctx.lineTo(r * 0.55, -r * 0.95);
                    ctx.lineTo(r * 0.2, -r * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    // Fangs
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.15, r * 0.05);
                    ctx.lineTo(-r * 0.1, r * 0.25);
                    ctx.lineTo(-r * 0.05, r * 0.05);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.05, r * 0.05);
                    ctx.lineTo(r * 0.1, r * 0.25);
                    ctx.lineTo(r * 0.15, r * 0.05);
                    ctx.fill();
                    break;

                case 'demon':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#8b0000';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r * 0.7, r * 0.85, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Wings
                    ctx.fillStyle = isStunned ? '#88a' : '#4a0000';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.5, -r * 0.2);
                    ctx.quadraticCurveTo(-r * 1.2, -r * 0.6, -r * 1.1, r * 0.1);
                    ctx.quadraticCurveTo(-r * 0.9, r * 0.3, -r * 0.5, r * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.5, -r * 0.2);
                    ctx.quadraticCurveTo(r * 1.2, -r * 0.6, r * 1.1, r * 0.1);
                    ctx.quadraticCurveTo(r * 0.9, r * 0.3, r * 0.5, r * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // Horns
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.3, -r * 0.6);
                    ctx.quadraticCurveTo(-r * 0.5, -r * 1.1, -r * 0.2, -r * 1.0);
                    ctx.lineTo(-r * 0.15, -r * 0.65);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, -r * 0.6);
                    ctx.quadraticCurveTo(r * 0.5, -r * 1.1, r * 0.2, -r * 1.0);
                    ctx.lineTo(r * 0.15, -r * 0.65);
                    ctx.closePath();
                    ctx.fill();
                    // Face
                    ctx.fillStyle = isStunned ? '#99e' : '#6b0000';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.25, r * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Glowing eyes
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#f80';
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.15, -r * 0.3, r * 0.1, r * 0.06, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.15, -r * 0.3, r * 0.1, r * 0.06, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Evil grin
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.15, r * 0.2, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                    // Tail
                    ctx.strokeStyle = isStunned ? '#aaf' : '#8b0000';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, r * 0.7);
                    ctx.quadraticCurveTo(r * 0.5, r * 1.0, r * 0.3, r * 1.2);
                    ctx.stroke();
                    // Tail point
                    ctx.fillStyle = isStunned ? '#aaf' : '#8b0000';
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, r * 1.15);
                    ctx.lineTo(r * 0.5, r * 1.3);
                    ctx.lineTo(r * 0.2, r * 1.25);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case 'fireElemental':
                    // Flame body with animation
                    const fireTime = Date.now() / 100;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#f80';
                    // Outer flames
                    ctx.fillStyle = isStunned ? 'rgba(150,150,255,0.6)' : 'rgba(255,100,0,0.6)';
                    for (let i = 0; i < 8; i++) {
                        const flameAngle = (i / 8) * Math.PI * 2;
                        const flameHeight = r * (0.8 + Math.sin(fireTime + i) * 0.3);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.quadraticCurveTo(
                            Math.cos(flameAngle) * r * 0.5,
                            Math.sin(flameAngle) * r * 0.5,
                            Math.cos(flameAngle) * flameHeight,
                            Math.sin(flameAngle) * flameHeight
                        );
                        ctx.quadraticCurveTo(
                            Math.cos(flameAngle + 0.2) * r * 0.3,
                            Math.sin(flameAngle + 0.2) * r * 0.3,
                            0, 0
                        );
                        ctx.fill();
                    }
                    // Core body
                    ctx.fillStyle = isStunned ? 'rgba(150,150,255,0.8)' : 'rgba(255,200,50,0.9)';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Inner core
                    ctx.fillStyle = isStunned ? '#aaf' : '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.12, -r * 0.1, r * 0.08, r * 0.12, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.12, -r * 0.1, r * 0.08, r * 0.12, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;

                case 'troll':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#556b2f';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.1, r * 0.8, r * 0.9, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Warty texture
                    ctx.fillStyle = isStunned ? '#99e' : '#445a1f';
                    for (let i = 0; i < 6; i++) {
                        const wx = (Math.random() - 0.5) * r * 1.2;
                        const wy = (Math.random() - 0.5) * r * 1.4;
                        ctx.beginPath();
                        ctx.arc(wx, wy, r * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Head
                    ctx.fillStyle = isStunned ? '#aaf' : '#556b2f';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.4, r * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Big nose
                    ctx.fillStyle = isStunned ? '#99e' : '#445a1f';
                    ctx.beginPath();
                    ctx.ellipse(0, -r * 0.2, r * 0.25, r * 0.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Small angry eyes
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(-r * 0.2, -r * 0.5, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.2, -r * 0.5, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.2, -r * 0.5, r * 0.04, 0, Math.PI * 2);
                    ctx.arc(r * 0.2, -r * 0.5, r * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    // Underbite with tusks
                    ctx.fillStyle = isStunned ? '#99e' : '#445a1f';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.1, r * 0.3, 0, Math.PI);
                    ctx.fill();
                    ctx.fillStyle = '#fffff0';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.2, -r * 0.1);
                    ctx.lineTo(-r * 0.25, -r * 0.35);
                    ctx.lineTo(-r * 0.1, -r * 0.1);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.2, -r * 0.1);
                    ctx.lineTo(r * 0.25, -r * 0.35);
                    ctx.lineTo(r * 0.1, -r * 0.1);
                    ctx.fill();
                    // Regen effect (green glow)
                    if (e.special === 'regen') {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#0f0';
                        ctx.strokeStyle = 'rgba(0,255,0,0.5)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, r * 0.9, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                    break;

                case 'medusa':
                    // Body
                    ctx.fillStyle = isStunned ? '#aaf' : '#228b22';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.2, r * 0.5, r * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Snake tail
                    ctx.strokeStyle = isStunned ? '#aaf' : '#228b22';
                    ctx.lineWidth = r * 0.3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, r * 0.6);
                    ctx.quadraticCurveTo(r * 0.4, r * 1.0, 0, r * 1.2);
                    ctx.stroke();
                    // Face
                    ctx.fillStyle = '#9acd32';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.2, r * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Snake hair
                    ctx.strokeStyle = isStunned ? '#99e' : '#228b22';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 8; i++) {
                        const snakeAngle = -Math.PI * 0.8 + (i * Math.PI * 0.2);
                        const snakeWave = Math.sin(Date.now() / 120 + i * 0.5) * r * 0.15;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(snakeAngle) * r * 0.3, -r * 0.3 + Math.sin(snakeAngle) * r * 0.2);
                        ctx.quadraticCurveTo(
                            Math.cos(snakeAngle) * r * 0.6 + snakeWave,
                            -r * 0.5 + Math.sin(snakeAngle) * r * 0.3,
                            Math.cos(snakeAngle) * r * 0.8,
                            -r * 0.7 + Math.sin(snakeAngle) * r * 0.4
                        );
                        ctx.stroke();
                        // Snake heads
                        ctx.fillStyle = isStunned ? '#99e' : '#1a6b1a';
                        ctx.beginPath();
                        ctx.arc(Math.cos(snakeAngle) * r * 0.8, -r * 0.7 + Math.sin(snakeAngle) * r * 0.4, r * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Eyes (glowing for petrify)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0';
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(-r * 0.15, -r * 0.25, r * 0.1, 0, Math.PI * 2);
                    ctx.arc(r * 0.15, -r * 0.25, r * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(-r * 0.15, -r * 0.25, r * 0.03, r * 0.07, 0, 0, Math.PI * 2);
                    ctx.ellipse(r * 0.15, -r * 0.25, r * 0.03, r * 0.07, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'griffin':
                    // Lion body
                    ctx.fillStyle = isStunned ? '#aaf' : '#daa520';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.2, r * 0.7, r * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Wings
                    ctx.fillStyle = isStunned ? '#99e' : '#8b6914';
                    const gWingFlap = Math.sin(Date.now() / 80) * 0.25;
                    ctx.save();
                    ctx.rotate(-0.5 + gWingFlap);
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.4, 0);
                    ctx.quadraticCurveTo(-r * 1.0, -r * 0.4, -r * 1.2, r * 0.1);
                    ctx.quadraticCurveTo(-r * 0.8, r * 0.2, -r * 0.4, 0);
                    ctx.fill();
                    // Feather details
                    ctx.strokeStyle = isStunned ? '#aaf' : '#c9a020';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.6, -r * 0.1);
                    ctx.lineTo(-r * 1.0, r * 0.05);
                    ctx.moveTo(-r * 0.7, 0);
                    ctx.lineTo(-r * 1.1, r * 0.1);
                    ctx.stroke();
                    ctx.restore();
                    ctx.save();
                    ctx.rotate(0.5 - gWingFlap);
                    ctx.beginPath();
                    ctx.moveTo(r * 0.4, 0);
                    ctx.quadraticCurveTo(r * 1.0, -r * 0.4, r * 1.2, r * 0.1);
                    ctx.quadraticCurveTo(r * 0.8, r * 0.2, r * 0.4, 0);
                    ctx.fill();
                    ctx.strokeStyle = isStunned ? '#aaf' : '#c9a020';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(r * 0.6, -r * 0.1);
                    ctx.lineTo(r * 1.0, r * 0.05);
                    ctx.moveTo(r * 0.7, 0);
                    ctx.lineTo(r * 1.1, r * 0.1);
                    ctx.stroke();
                    ctx.restore();
                    // Eagle head
                    ctx.fillStyle = isStunned ? '#aaf' : '#f5deb3';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.35, r * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Beak
                    ctx.fillStyle = '#f4a460';
                    ctx.beginPath();
                    ctx.moveTo(0, -r * 0.3);
                    ctx.lineTo(r * 0.15, -r * 0.15);
                    ctx.lineTo(0, r * 0.0);
                    ctx.lineTo(-r * 0.15, -r * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r * 0.15, -r * 0.4, r * 0.08, 0, Math.PI * 2);
                    ctx.arc(r * 0.15, -r * 0.4, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(-r * 0.15, -r * 0.4, r * 0.04, 0, Math.PI * 2);
                    ctx.arc(r * 0.15, -r * 0.4, r * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    // Tail tuft
                    ctx.fillStyle = isStunned ? '#aaf' : '#daa520';
                    ctx.beginPath();
                    ctx.moveTo(0, r * 0.7);
                    ctx.quadraticCurveTo(-r * 0.2, r * 1.0, -r * 0.1, r * 1.1);
                    ctx.quadraticCurveTo(0, r * 0.9, r * 0.1, r * 1.1);
                    ctx.quadraticCurveTo(r * 0.2, r * 1.0, 0, r * 0.7);
                    ctx.fill();
                    break;

                case 'necromancer':
                    // Dark robe
                    ctx.fillStyle = isStunned ? '#66a' : '#1a0a2a';
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.4, -r * 0.4);
                    ctx.lineTo(-r * 0.7, r);
                    ctx.lineTo(r * 0.7, r);
                    ctx.lineTo(r * 0.4, -r * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    // Hood
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.3, r * 0.5, Math.PI, 0);
                    ctx.lineTo(r * 0.4, -r * 0.1);
                    ctx.quadraticCurveTo(0, r * 0.1, -r * 0.4, -r * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // Shadow face
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0, -r * 0.2, r * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Glowing eyes
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#a0f';
                    ctx.fillStyle = '#a0f';
                    ctx.beginPath();
                    ctx.arc(-r * 0.12, -r * 0.25, r * 0.06, 0, Math.PI * 2);
                    ctx.arc(r * 0.12, -r * 0.25, r * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Staff
                    ctx.strokeStyle = '#3a2a1a';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(r * 0.5, -r * 0.5);
                    ctx.lineTo(r * 0.5, r * 0.9);
                    ctx.stroke();
                    // Skull on staff
                    ctx.fillStyle = '#ddd';
                    ctx.beginPath();
                    ctx.arc(r * 0.5, -r * 0.6, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(r * 0.45, -r * 0.62, r * 0.04, 0, Math.PI * 2);
                    ctx.arc(r * 0.55, -r * 0.62, r * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    // Dark magic aura
                    ctx.strokeStyle = 'rgba(160,0,255,0.4)';
                    ctx.lineWidth = 2;
                    const auraPhase = Date.now() / 200;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(0, 0, r * (0.7 + i * 0.15 + Math.sin(auraPhase + i) * 0.1), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    // Floating runes
                    ctx.fillStyle = 'rgba(160,0,255,0.6)';
                    ctx.font = `${r * 0.2}px serif`;
                    const runes = ['', '', ''];
                    for (let i = 0; i < 3; i++) {
                        const runeAngle = auraPhase + (i * Math.PI * 2 / 3);
                        const runeX = Math.cos(runeAngle) * r * 0.8;
                        const runeY = Math.sin(runeAngle) * r * 0.8;
                        ctx.fillText(runes[i], runeX - r * 0.05, runeY + r * 0.05);
                    }
                    break;

                default:
                    // Fallback circle
                    ctx.fillStyle = isStunned ? '#aaf' : e.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
            }

            ctx.restore();

            // Health bar (drawn in world space)
            ctx.save();
            const barWidth = e.radius * 2;
            const barHeight = 4;
            ctx.fillStyle = '#333';
            ctx.fillRect(e.x - barWidth/2, e.y - e.radius - 15, barWidth, barHeight);
            ctx.fillStyle = e.health > e.maxHealth * 0.3 ? '#4a4' : '#a44';
            ctx.fillRect(e.x - barWidth/2, e.y - e.radius - 15, barWidth * (e.health / e.maxHealth), barHeight);
            ctx.restore();
        }

        function drawBullet(b) {
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(b.angle || 0);

            const color = classDefinitions[player.class]?.color || '#ffd700';

            switch(b.type) {
                case 'magic':
                    ctx.fillStyle = b.isCrit ? '#ffff00' : '#00ffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = b.isCrit ? '#ffff00' : '#00ffff';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;

                case 'axe':
                    ctx.fillStyle = b.isCrit ? '#ffff00' : '#8b4513';
                    ctx.beginPath();
                    ctx.moveTo(b.radius, 0);
                    ctx.lineTo(0, -b.radius);
                    ctx.lineTo(-b.radius * 0.5, 0);
                    ctx.lineTo(0, b.radius);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#666';
                    ctx.fillRect(-b.radius * 0.3, -2, b.radius, 4);
                    break;

                case 'shuriken':
                    ctx.fillStyle = b.isCrit ? '#ffff00' : '#c0c0c0';
                    for (let i = 0; i < 4; i++) {
                        ctx.save();
                        ctx.rotate((Math.PI / 2) * i);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(b.radius, -b.radius * 0.3);
                        ctx.lineTo(b.radius * 0.3, 0);
                        ctx.lineTo(b.radius, b.radius * 0.3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    break;

                case 'sword':
                    ctx.fillStyle = b.isCrit ? '#ffff00' : '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(b.radius, 0);
                    ctx.lineTo(-b.radius * 0.5, -b.radius * 0.4);
                    ctx.lineTo(-b.radius * 0.5, b.radius * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(-b.radius * 0.8, -b.radius * 0.2, b.radius * 0.4, b.radius * 0.4);
                    break;

                default:
                    ctx.fillStyle = b.isCrit ? '#ffff00' : '#ffd700';
                    ctx.beginPath();
                    ctx.arc(0, 0, b.radius, 0, Math.PI * 2);
                    ctx.fill();
            }

            ctx.restore();
        }

        // ===== MAP PROP RENDERING =====
        function drawMapProps() {
            for (const prop of mapProps) {
                // Only draw props on screen
                if (!isOnScreen(prop.x, prop.y, 100)) continue;

                ctx.save();
                ctx.translate(prop.x, prop.y);
                ctx.scale(prop.scale, prop.scale);

                switch(prop.type) {
                    case 'tree':
                        // Tree trunk
                        ctx.fillStyle = '#4a3728';
                        ctx.fillRect(-8, -10, 16, 60);
                        // Tree foliage
                        ctx.fillStyle = '#2d5a2d';
                        ctx.beginPath();
                        ctx.arc(0, -30, 40, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#1a4a1a';
                        ctx.beginPath();
                        ctx.arc(-15, -20, 25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(15, -25, 28, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'pine':
                        // Pine trunk
                        ctx.fillStyle = '#3a2718';
                        ctx.fillRect(-6, 0, 12, 50);
                        // Pine layers
                        ctx.fillStyle = '#1a4a1a';
                        ctx.beginPath();
                        ctx.moveTo(0, -60);
                        ctx.lineTo(-25, -20);
                        ctx.lineTo(25, -20);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(0, -40);
                        ctx.lineTo(-30, 0);
                        ctx.lineTo(30, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(0, -20);
                        ctx.lineTo(-35, 20);
                        ctx.lineTo(35, 20);
                        ctx.closePath();
                        ctx.fill();
                        break;

                    case 'willow':
                        // Willow trunk
                        ctx.fillStyle = '#5a4738';
                        ctx.fillRect(-10, -5, 20, 55);
                        // Drooping branches
                        ctx.strokeStyle = '#3a6a3a';
                        ctx.lineWidth = 3;
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            ctx.beginPath();
                            ctx.moveTo(Math.cos(angle) * 10, -20);
                            ctx.quadraticCurveTo(
                                Math.cos(angle) * 50, -10,
                                Math.cos(angle) * 40, 40
                            );
                            ctx.stroke();
                        }
                        ctx.fillStyle = '#2a5a2a';
                        ctx.beginPath();
                        ctx.arc(0, -25, 30, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'bush':
                        ctx.fillStyle = ['#2a5a2a', '#3a6a3a', '#1a4a1a'][prop.variant];
                        ctx.beginPath();
                        ctx.arc(0, 0, 20, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#3a7a3a';
                        ctx.beginPath();
                        ctx.arc(-8, -5, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(8, -3, 10, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'flowers':
                        // Flower stems
                        ctx.strokeStyle = '#2a5a2a';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * 8 - 8, 10);
                            ctx.lineTo(i * 8 - 8, -5);
                            ctx.stroke();
                        }
                        // Flower petals
                        ctx.fillStyle = prop.color;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.arc(i * 8 - 8, -8, 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // Centers
                        ctx.fillStyle = '#ffff00';
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.arc(i * 8 - 8, -8, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;

                    case 'mushroom':
                        // Stem
                        ctx.fillStyle = '#f5f5dc';
                        ctx.fillRect(-4, 0, 8, 12);
                        // Cap
                        ctx.fillStyle = prop.color;
                        ctx.beginPath();
                        ctx.arc(0, 0, 10, Math.PI, 0);
                        ctx.fill();
                        // Spots
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(-4, -3, 2, 0, Math.PI * 2);
                        ctx.arc(3, -5, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'rock':
                        ctx.fillStyle = '#666';
                        ctx.beginPath();
                        ctx.moveTo(-20, 10);
                        ctx.lineTo(-25, -5);
                        ctx.lineTo(-10, -15);
                        ctx.lineTo(10, -12);
                        ctx.lineTo(25, 0);
                        ctx.lineTo(20, 10);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#888';
                        ctx.beginPath();
                        ctx.moveTo(-10, -15);
                        ctx.lineTo(0, -20);
                        ctx.lineTo(10, -12);
                        ctx.closePath();
                        ctx.fill();
                        break;

                    case 'crystal':
                        // Glowing crystal
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = prop.color;
                        ctx.fillStyle = prop.color;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(0, -25);
                        ctx.lineTo(-8, 0);
                        ctx.lineTo(-5, 10);
                        ctx.lineTo(5, 10);
                        ctx.lineTo(8, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(-2, -20);
                        ctx.lineTo(-5, -5);
                        ctx.lineTo(-2, -5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                        break;
                }

                ctx.restore();
            }
        }

        // ===== HAZARD RENDERING =====
        function drawHazards() {
            const now = Date.now();

            for (const h of hazards) {
                if (!isOnScreen(h.x, h.y, 100)) continue;

                ctx.save();
                ctx.translate(h.x, h.y);

                switch(h.type) {
                    case 'thorns':
                        // Thorn patch
                        ctx.fillStyle = '#4a3a2a';
                        ctx.beginPath();
                        ctx.arc(0, 0, h.radius, 0, Math.PI * 2);
                        ctx.fill();
                        // Thorns
                        ctx.fillStyle = '#2a4a2a';
                        ctx.strokeStyle = '#5a3a1a';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2;
                            const r = h.radius * 0.7;
                            ctx.beginPath();
                            ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                            ctx.lineTo(Math.cos(angle) * (r + 15), Math.sin(angle) * (r + 15));
                            ctx.stroke();
                        }
                        // Health bar
                        if (h.health < h.maxHealth) {
                            ctx.fillStyle = '#333';
                            ctx.fillRect(-20, -h.radius - 15, 40, 6);
                            ctx.fillStyle = '#aa4444';
                            ctx.fillRect(-20, -h.radius - 15, 40 * (h.health / h.maxHealth), 6);
                        }
                        break;

                    case 'spore':
                        // Spore plant
                        const pulse = Math.sin(now / 300 + h.x) * 0.2 + 1;
                        ctx.fillStyle = '#6a4a8a';
                        ctx.beginPath();
                        ctx.arc(0, 0, h.radius * pulse, 0, Math.PI * 2);
                        ctx.fill();
                        // Poison cloud
                        ctx.fillStyle = 'rgba(100, 200, 100, 0.2)';
                        ctx.beginPath();
                        ctx.arc(0, 0, h.damageRadius, 0, Math.PI * 2);
                        ctx.fill();
                        // Spores
                        ctx.fillStyle = '#88ff88';
                        for (let i = 0; i < 5; i++) {
                            const angle = (now / 1000 + i) % (Math.PI * 2);
                            const dist = 20 + Math.sin(now / 500 + i) * 10;
                            ctx.beginPath();
                            ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // Health bar
                        if (h.health < h.maxHealth) {
                            ctx.fillStyle = '#333';
                            ctx.fillRect(-20, -h.radius - 20, 40, 6);
                            ctx.fillStyle = '#aa44aa';
                            ctx.fillRect(-20, -h.radius - 20, 40 * (h.health / h.maxHealth), 6);
                        }
                        break;

                    case 'geyser':
                        // Geyser base
                        ctx.fillStyle = '#4a3a3a';
                        ctx.beginPath();
                        ctx.arc(0, 0, h.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#2a1a1a';
                        ctx.beginPath();
                        ctx.arc(0, 0, h.radius * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        // Warning glow when about to fire
                        const timeToFire = h.cooldown - (now - h.lastFire);
                        if (timeToFire < 1000 && timeToFire > 0) {
                            ctx.fillStyle = `rgba(255, 68, 0, ${0.5 * (1 - timeToFire / 1000)})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, h.damageRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // Active fire
                        if (h.firing) {
                            ctx.fillStyle = 'rgba(255, 100, 0, 0.6)';
                            ctx.beginPath();
                            ctx.arc(0, 0, h.damageRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // Health bar
                        if (h.health < h.maxHealth) {
                            ctx.fillStyle = '#333';
                            ctx.fillRect(-20, -h.radius - 15, 40, 6);
                            ctx.fillStyle = '#ff4400';
                            ctx.fillRect(-20, -h.radius - 15, 40 * (h.health / h.maxHealth), 6);
                        }
                        break;

                    case 'turret':
                        // Turret base
                        ctx.fillStyle = '#5a5a7a';
                        ctx.beginPath();
                        ctx.arc(0, 0, h.radius, 0, Math.PI * 2);
                        ctx.fill();
                        // Turret top
                        const aimAngle = Math.atan2(player.y - h.y, player.x - h.x);
                        ctx.save();
                        ctx.rotate(aimAngle);
                        ctx.fillStyle = '#3a3a5a';
                        ctx.fillRect(-5, -8, 25, 16);
                        ctx.fillStyle = '#8a8aaa';
                        ctx.beginPath();
                        ctx.arc(0, 0, 12, 0, Math.PI * 2);
                        ctx.fill();
                        // Glowing eye
                        ctx.fillStyle = '#ff00ff';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ff00ff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.restore();
                        // Range indicator
                        ctx.strokeStyle = 'rgba(255, 0, 255, 0.1)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 10]);
                        ctx.beginPath();
                        ctx.arc(0, 0, h.range, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        // Health bar
                        if (h.health < h.maxHealth) {
                            ctx.fillStyle = '#333';
                            ctx.fillRect(-20, -h.radius - 15, 40, 6);
                            ctx.fillStyle = '#aa44ff';
                            ctx.fillRect(-20, -h.radius - 15, 40 * (h.health / h.maxHealth), 6);
                        }
                        break;
                }

                ctx.restore();
            }
        }

        // ===== TREASURE CHEST RENDERING =====
        function drawChests() {
            const now = Date.now();

            for (const chest of treasureChests) {
                if (chest.opened || !isOnScreen(chest.x, chest.y, 50)) continue;

                ctx.save();
                ctx.translate(chest.x, chest.y);

                // Floating bob animation
                const bob = Math.sin(now / 300 + chest.bobOffset) * 3;
                ctx.translate(0, bob);

                // Glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffd700';

                // Chest body
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(-18, -8, 36, 20);

                // Chest lid
                ctx.fillStyle = '#a0522d';
                ctx.beginPath();
                ctx.moveTo(-20, -8);
                ctx.lineTo(-18, -18);
                ctx.lineTo(18, -18);
                ctx.lineTo(20, -8);
                ctx.closePath();
                ctx.fill();

                // Gold trim
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(-18, -8, 36, 20);
                ctx.beginPath();
                ctx.moveTo(-20, -8);
                ctx.lineTo(-18, -18);
                ctx.lineTo(18, -18);
                ctx.lineTo(20, -8);
                ctx.closePath();
                ctx.stroke();

                // Lock
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-5, -5, 10, 10);
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();

                // Sparkles
                ctx.fillStyle = '#fff';
                for (let i = 0; i < 3; i++) {
                    const sparkleAngle = (now / 500 + i * 2) % (Math.PI * 2);
                    const sparkleX = Math.cos(sparkleAngle) * 25;
                    const sparkleY = Math.sin(sparkleAngle) * 15 - 5;
                    ctx.globalAlpha = 0.5 + Math.sin(now / 200 + i) * 0.3;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;

                ctx.restore();
            }
        }

        function draw() {
            // Clear screen
            ctx.fillStyle = '#1a3d1a';
            ctx.fillRect(0, 0, W, H);

            // Apply camera transform for world rendering
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw lush forest floor - organic pattern (no grid)
            // Base gradient
            const baseGradient = ctx.createRadialGradient(
                camera.x + W/2, camera.y + H/2, 0,
                camera.x + W/2, camera.y + H/2, W
            );
            baseGradient.addColorStop(0, '#2d5a2d');
            baseGradient.addColorStop(0.5, '#1e4d1e');
            baseGradient.addColorStop(1, '#1a3d1a');
            ctx.fillStyle = baseGradient;
            ctx.fillRect(camera.x - 50, camera.y - 50, W + 100, H + 100);

            // Organic grass patches using seeded noise pattern
            const patchSize = 200;
            const startX = Math.floor(camera.x / patchSize) * patchSize;
            const startY = Math.floor(camera.y / patchSize) * patchSize;

            for (let x = startX - patchSize; x < camera.x + W + patchSize; x += patchSize) {
                for (let y = startY - patchSize; y < camera.y + H + patchSize; y += patchSize) {
                    // Create organic grass clumps
                    const seed = (x * 73 + y * 137) % 1000;
                    const clumps = 4 + (seed % 4);

                    for (let c = 0; c < clumps; c++) {
                        const cx = x + ((seed * (c + 1) * 17) % patchSize);
                        const cy = y + ((seed * (c + 1) * 23) % patchSize);
                        const radius = 30 + ((seed * (c + 1)) % 50);

                        // Soft grass patch
                        const grassGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
                        const brightness = 0.15 + ((seed + c) % 10) / 50;
                        grassGrad.addColorStop(0, `rgba(60, 120, 40, ${brightness})`);
                        grassGrad.addColorStop(0.6, `rgba(40, 90, 30, ${brightness * 0.5})`);
                        grassGrad.addColorStop(1, 'rgba(30, 70, 30, 0)');
                        ctx.fillStyle = grassGrad;
                        ctx.beginPath();
                        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Subtle darker patches for depth
                    const darkPatches = 2 + (seed % 3);
                    for (let d = 0; d < darkPatches; d++) {
                        const dx = x + ((seed * (d + 7) * 31) % patchSize);
                        const dy = y + ((seed * (d + 7) * 41) % patchSize);
                        const dRadius = 20 + ((seed * d) % 30);

                        const darkGrad = ctx.createRadialGradient(dx, dy, 0, dx, dy, dRadius);
                        darkGrad.addColorStop(0, 'rgba(15, 35, 15, 0.3)');
                        darkGrad.addColorStop(1, 'rgba(15, 35, 15, 0)');
                        ctx.fillStyle = darkGrad;
                        ctx.beginPath();
                        ctx.arc(dx, dy, dRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Small highlight spots (dappled sunlight)
                    const highlights = 3 + (seed % 4);
                    for (let h = 0; h < highlights; h++) {
                        const hx = x + ((seed * (h + 3) * 47) % patchSize);
                        const hy = y + ((seed * (h + 3) * 53) % patchSize);
                        const hRadius = 8 + ((seed * h) % 15);

                        const lightGrad = ctx.createRadialGradient(hx, hy, 0, hx, hy, hRadius);
                        lightGrad.addColorStop(0, 'rgba(120, 180, 80, 0.15)');
                        lightGrad.addColorStop(1, 'rgba(100, 160, 60, 0)');
                        ctx.fillStyle = lightGrad;
                        ctx.beginPath();
                        ctx.arc(hx, hy, hRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw world boundary
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.6)';
            ctx.lineWidth = 8;
            ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            ctx.strokeStyle = 'rgba(85, 45, 10, 0.8)';
            ctx.lineWidth = 3;
            ctx.strokeRect(4, 4, WORLD_WIDTH - 8, WORLD_HEIGHT - 8);

            // Draw map props (behind entities)
            drawMapProps();

            // Draw hazards
            drawHazards();

            // Draw treasure chests
            drawChests();

            // Particles (in world space)
            for (const p of particles) {
                ctx.globalAlpha = p.life / 40;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Hazard projectiles
            for (const p of hazardProjectiles) {
                ctx.fillStyle = '#ff00ff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff00ff';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Soul orbs
            for (const orb of soulOrbs) {
                const pulse = 0.8 + Math.sin(Date.now() / 100 + orb.x) * 0.2;
                const alpha = Math.min(1, orb.life / 60);
                ctx.globalAlpha = alpha;

                // Outer glow
                const gradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, 15 * pulse);
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 180, 0, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, 15 * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, 6 * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Inner bright spot
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(orb.x - 2, orb.y - 2, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Bullets
            for (const b of bullets) {
                drawBullet(b);
            }

            // Enemies
            for (const e of enemies) {
                drawEnemy(e);
            }

            // Player
            if (gameState === 'playing') {
                drawPlayer();
            }

            // Soul magnet radius indicator (in world space)
            if (player.soulMagnetRadius > 0 && gameState === 'playing') {
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.15)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.soulMagnetRadius + (player.tempMagnetBonus || 0), 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw active ability effects around player (in world space)
            if (gameState === 'playing') {
                const now = Date.now();

                // Battle Rage effect - red pulsing aura
                if (player.rageActive) {
                    const pulse = 0.5 + Math.sin(now / 100) * 0.2;
                    ctx.strokeStyle = `rgba(255, 68, 0, ${pulse})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 10 + Math.sin(now / 80) * 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = `rgba(255, 100, 0, ${pulse * 0.5})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 18 + Math.sin(now / 120) * 4, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Shield Wall effect - golden rotating shield
                if (player.shieldActive) {
                    ctx.save();
                    ctx.translate(player.x, player.y);
                    ctx.rotate(now / 500);
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, player.radius + 15, angle, angle + 0.5);
                        ctx.stroke();
                    }
                    ctx.restore();
                    // Inner glow
                    const gradient = ctx.createRadialGradient(player.x, player.y, player.radius, player.x, player.y, player.radius + 25);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 25, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Arcane Nova expanding ring effect
                if (player.novaEffect && now - player.novaEffect.time < 500) {
                    const progress = (now - player.novaEffect.time) / 500;
                    const radius = player.novaEffect.radius * progress;
                    ctx.strokeStyle = `rgba(0, 255, 255, ${1 - progress})`;
                    ctx.lineWidth = 4 * (1 - progress);
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = `rgba(147, 112, 219, ${(1 - progress) * 0.5})`;
                    ctx.lineWidth = 8 * (1 - progress);
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, radius * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Restore camera transform (back to screen space)
            ctx.restore();

            // ===== UI ELEMENTS (Screen Space) =====

            // Health bar
            const hbW = 200, hbH = 20;
            ctx.fillStyle = '#333';
            ctx.fillRect(W - hbW - 20, 20, hbW, hbH);

            // Rage indicator for barbarian
            let healthColor = player.health > player.maxHealth * 0.3 ? '#4a4' : '#a44';
            if (player.class === 'barbarian' && player.rageDamage && player.health < player.maxHealth * 0.5) {
                healthColor = '#ff4400';
            }
            ctx.fillStyle = healthColor;
            ctx.fillRect(W - hbW - 20, 20, hbW * (player.health / player.maxHealth), hbH);
            ctx.strokeStyle = classDefinitions[player.class]?.color || '#c9a227';
            ctx.lineWidth = 2;
            ctx.strokeRect(W - hbW - 20, 20, hbW, hbH);
            ctx.fillStyle = '#fff';
            ctx.font = '14px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.ceil(player.health)} / ${player.maxHealth}`, W - hbW/2 - 20, 35);

            // Ability cooldown bar
            if (player.class && classDefinitions[player.class]) {
                const classDef = classDefinitions[player.class];
                const now = Date.now();
                const cooldownTotal = classDef.abilityCooldown * player.abilityCooldownMult;
                const cooldownRemaining = Math.max(0, player.abilityCooldownEnd - now);
                const cooldownProgress = 1 - (cooldownRemaining / cooldownTotal);

                const abW = 200, abH = 16;
                const abY = 48;

                // Background
                ctx.fillStyle = '#333';
                ctx.fillRect(W - abW - 20, abY, abW, abH);

                // Cooldown fill
                if (cooldownProgress >= 1) {
                    ctx.fillStyle = classDef.color;
                } else {
                    ctx.fillStyle = '#666';
                }
                ctx.fillRect(W - abW - 20, abY, abW * Math.min(1, cooldownProgress), abH);

                // Active ability indicator
                if (player.rageActive || player.shieldActive) {
                    const activeProgress = (player.abilityActiveEnd - now) / (classDef.abilityDuration * player.abilityDurationMult);
                    ctx.fillStyle = player.rageActive ? '#ff4400' : '#ffd700';
                    ctx.fillRect(W - abW - 20, abY, abW * Math.max(0, activeProgress), abH);
                }

                // Border
                ctx.strokeStyle = classDef.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(W - abW - 20, abY, abW, abH);

                // Ability name and key
                ctx.fillStyle = '#fff';
                ctx.font = '12px Georgia';
                ctx.textAlign = 'center';
                const abilityText = cooldownProgress >= 1 ? `[SPACE] ${classDef.abilityName}` : `${classDef.abilityName} (${(cooldownRemaining / 1000).toFixed(1)}s)`;
                ctx.fillText(abilityText, W - abW/2 - 20, abY + 12);
            }

            // Combo counter (top left)
            if (player.comboCount > 0 && player.comboBonus > 0) {
                const comboAlpha = Math.min(1, (2000 - (Date.now() - player.lastHitTime)) / 500);
                if (comboAlpha > 0) {
                    ctx.globalAlpha = comboAlpha;
                    ctx.font = 'bold 24px Georgia';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = player.comboCount >= player.comboMax ? '#ff4400' : '#ffd700';
                    ctx.fillText(`${player.comboCount}x COMBO`, 20, 80);
                    const bonusPercent = Math.round(player.comboBonus * player.comboCount * 100);
                    ctx.font = '14px Georgia';
                    ctx.fillStyle = '#aaa';
                    ctx.fillText(`+${bonusPercent}% damage`, 20, 100);
                    ctx.globalAlpha = 1;
                }
            }

            // Wave timer display (center top)
            if (gameState === 'playing') {
                const timeRemaining = Math.max(0, waveTimeLimit - waveTimer);
                const seconds = Math.ceil(timeRemaining / 1000);
                const progress = waveTimer / waveTimeLimit;

                // Timer bar background
                const tbW = 300, tbH = 25;
                const tbX = (W - tbW) / 2;
                const tbY = 15;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(tbX - 5, tbY - 5, tbW + 10, tbH + 30);

                ctx.fillStyle = '#333';
                ctx.fillRect(tbX, tbY, tbW, tbH);

                // Progress fill (green -> yellow -> red as time runs out)
                const timerColor = progress < 0.5 ? '#44aa44' : progress < 0.8 ? '#aaaa44' : '#aa4444';
                ctx.fillStyle = timerColor;
                ctx.fillRect(tbX, tbY, tbW * progress, tbH);

                ctx.strokeStyle = '#c9a227';
                ctx.lineWidth = 2;
                ctx.strokeRect(tbX, tbY, tbW, tbH);

                // Timer text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Georgia';
                ctx.textAlign = 'center';
                ctx.fillText(`WAVE ${wave} - ${seconds}s`, W / 2, tbY + 18);

                // Subtitle
                ctx.font = '12px Georgia';
                ctx.fillStyle = '#aaa';
                ctx.fillText('Survive to advance!', W / 2, tbY + 38);
            }

            // Active buffs display (below wave timer)
            if (activeBuffs.length > 0) {
                const buffY = 70;
                const buffSize = 40;
                const startX = (W - activeBuffs.length * (buffSize + 5)) / 2;

                ctx.font = '10px Georgia';
                ctx.textAlign = 'center';

                for (let i = 0; i < activeBuffs.length; i++) {
                    const buff = activeBuffs[i];
                    const x = startX + i * (buffSize + 5);
                    const timeLeft = (buff.endTime - Date.now()) / 1000;
                    const progress = timeLeft / (buff.duration / 1000);

                    // Buff icon background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(x, buffY, buffSize, buffSize);

                    // Buff color fill based on time remaining
                    ctx.fillStyle = buff.color;
                    ctx.globalAlpha = 0.7;
                    ctx.fillRect(x, buffY + buffSize * (1 - progress), buffSize, buffSize * progress);
                    ctx.globalAlpha = 1;

                    // Border
                    ctx.strokeStyle = buff.color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, buffY, buffSize, buffSize);

                    // Buff initial
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Georgia';
                    ctx.fillText(buff.name[0], x + buffSize / 2, buffY + 25);

                    // Time remaining
                    ctx.font = '10px Georgia';
                    ctx.fillText(timeLeft.toFixed(1), x + buffSize / 2, buffY + buffSize + 12);
                }
            }

            // Minimap (bottom right)
            const mmSize = 150;
            const mmX = W - mmSize - 15;
            const mmY = H - mmSize - 15;
            const mmScale = mmSize / WORLD_WIDTH;

            // Minimap background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(mmX - 2, mmY - 2, mmSize + 4, mmSize + 4);
            ctx.fillStyle = '#1a3d1a';
            ctx.fillRect(mmX, mmY, mmSize, mmSize);

            // Minimap border
            ctx.strokeStyle = '#c9a227';
            ctx.lineWidth = 2;
            ctx.strokeRect(mmX, mmY, mmSize, mmSize);

            // Viewport rectangle
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.strokeRect(
                mmX + camera.x * mmScale,
                mmY + camera.y * mmScale,
                W * mmScale,
                H * mmScale
            );

            // Hazards on minimap
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            for (const h of hazards) {
                ctx.beginPath();
                ctx.arc(mmX + h.x * mmScale, mmY + h.y * mmScale, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Chests on minimap
            ctx.fillStyle = '#ffd700';
            for (const c of treasureChests) {
                if (!c.opened) {
                    ctx.fillRect(mmX + c.x * mmScale - 2, mmY + c.y * mmScale - 2, 4, 4);
                }
            }

            // Enemies on minimap
            ctx.fillStyle = '#ff4444';
            for (const e of enemies) {
                ctx.beginPath();
                ctx.arc(mmX + e.x * mmScale, mmY + e.y * mmScale, e.isBoss ? 4 : 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Player on minimap
            ctx.fillStyle = '#44ff44';
            ctx.beginPath();
            ctx.arc(mmX + player.x * mmScale, mmY + player.y * mmScale, 4, 0, Math.PI * 2);
            ctx.fill();

            // Update HTML UI
            document.getElementById('health').textContent = `Health: ${Math.ceil(player.health)}`;
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('souls').textContent = `Souls: ${souls}`;
            document.getElementById('wave').textContent = `Wave: ${wave}`;
            document.getElementById('enemies').textContent = `Enemies: ${enemies.length}`;
        }

        function gameLoop() {
            const deltaTime = 16.67; // ~60fps

            if (gameState === 'playing') {
                updatePlayer();
                updateAbilities();
                updateBullets();
                updateEnemies();
                updateSoulOrbs();
                updateParticles();
                updateHazards();
                updateChests();

                // Update wave timer
                waveTimer += deltaTime;

                // Continuous enemy spawning
                enemySpawnTimer += deltaTime;
                if (enemySpawnTimer >= enemySpawnRate) {
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }

                // Decay combo if no hits for a while
                if (Date.now() - player.lastHitTime > 2000) {
                    player.comboCount = 0;
                }

                // Time-based wave completion
                if (waveTimer >= waveTimeLimit) {
                    wave++;
                    gameState = 'upgrading';
                    playSound('waveComplete');
                    showUpgradeMenu();
                }

                // Check player death
                if (player.health <= 0) {
                    gameState = 'gameover';
                    document.getElementById('finalScore').textContent = `Final Score: ${score}`;
                    document.getElementById('finalWave').textContent = `Reached Wave: ${wave}`;
                    document.getElementById('gameOver').style.display = 'block';
                    playSound('playerHit');
                }
            }

            draw();
            requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>
